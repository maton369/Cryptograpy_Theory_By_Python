# Miller-Rabin 素数判定（確率的素数判定）
# -----------------------------------------------------------------------------
# 目的
# - 大きな整数 n が「素数らしいか」を高速に判定する。
# - RSA 鍵生成などでは巨大な素数が必要なので、素数判定は暗号理論の基礎部品になる。
#
# Miller-Rabin の特徴
# - 「確率的」判定：
#   - True が返っても “確実に素数” とは限らず、「強い確率で素数（probable prime）」を意味する。
#   - False が返った場合は “確実に合成数” である（偽陰性は起きない）。
#
# - 反復回数 L を増やすほど、合成数を素数と誤判定する確率が指数的に小さくなる。
#   典型的には、ランダムな底 a を選ぶ Miller-Rabin では
#     合成数が 1 回の試行をすり抜ける確率は高くても 1/4
#   なので、L 回で高々 (1/4)^L まで落ちる（理論上の上限）。
#
# - 実務では「乱数で底を選ぶ」よりも、
#   ある範囲の n について決定的になる “固定の底の集合” を使う実装も多い
#   （例：64bit整数なら少数の底で決定的に判定可能など）。
#
# -----------------------------------------------------------------------------
v# アルゴリズムの数学（核）
# -----------------------------------------------------------------------------
# n が奇数で素数なら、フェルマーの小定理より
#   a^(n-1) ≡ 1 (mod n)   （a と n が互いに素なら）
# が成り立つ。
#
# Miller-Rabin は n-1 を
#   n-1 = 2^s * d  （d は奇数）
# と分解し、
#   a^d, a^(2d), a^(4d), ..., a^(2^(s-1)d)
# を順に調べて、
# - 途中で -1（mod n）に到達するか
# - 最初が 1（mod n）になるか
# をチェックすることで「合成数を強く弾く」。
#
# 素数なら必ず
# - a^d ≡ 1 (mod n)
#   または
# - ある r で a^(2^r d) ≡ -1 (mod n)
# が成立する（“平方していく過程で -1 に当たる”）。
#
# 合成数ではこの性質が壊れることが多く、ランダムな a を選べば高確率で検出できる。
#
# -----------------------------------------------------------------------------
# 実装上の注意
# -----------------------------------------------------------------------------
# - 本コードは random.randint を使っており、暗号用途の乱数としては不十分。
#   暗号用途なら secrets.randbelow など CSPRNG を使うのが定石。
# - ただし Miller-Rabin の「底 a の選び方」は、素数判定の正しさの観点では
#   乱数でも良いが、攻撃モデルや鍵生成の設計では CSPRNG を使うのが安全。
#
# - 典型実装では a は [2, n-2] の範囲で選ぶことが多い（n-1 は常に 1 mod n で意味が薄い）。


import random


def MillerRabin(n, L=50):
    # n: 判定したい整数
    # L: 試行回数（底 a のランダム選択回数）
    #
    # 戻り値：
    # - True  : n は “おそらく素数”（probable prime）
    # - False : n は “確実に合成数”
    #
    # -------------------------
    # 0) 明らかな小ケース処理
    # -------------------------
    if n == 2:
        # 2 は素数
        return True

    if (n < 2) or (n % 2 == 0):
        # 0,1 や負数は素数ではない
        # 偶数（2以外）は合成数
        return False

    # ここ以降は n は奇数（n >= 3）と仮定できる

    # -------------------------
    # 1) n-1 を 2^s * d に分解（d を奇数にする）
    # -------------------------
    # この実装は変数 t を使って “奇数部分 d” を作っている。
    #
    #   n - 1 = 2^s * d
    #   d は奇数
    #
    # まず t = (n-1)/2 を作り、2で割れる限り割っていくことで最終的に奇数の d を得る。
    # ※典型的には t = n-1 から始めて s を数えるが、ここは等価なやり方。
    t = (n - 1) >> 1  # (n-1)/2

    # t が偶数なら 2で割り続け、奇数になったら止める
    while (t % 2) == 0:
        t >>= 1

    # この時点で t は n-1 の奇数部分（d）になっている。
    # ※ただし、この実装は “s の値” を明示的には保持していない。

    # -------------------------
    # 2) L 回、ランダムな底 a を選んで「強擬素数テスト」を行う
    # -------------------------
    for i in range(L):
        # 底 a をランダム選択
        # 典型は 2..n-2 だが、この実装は 2..n-1 を含む。
        # a=n-1 だと a≡-1 (mod n) なのでテストが常に通りやすく、情報量が少ない。
        a = random.randint(2, n - 1)

        # tmp は現在の指数（最初は d に相当）
        tmp = t

        # b = a^tmp mod n を計算
        # Python の pow(a, tmp, n) は高速な modular exponentiation（繰り返し二乗法）。
        b = pow(a, tmp, n)

        # -------------------------
        # 3) 平方を繰り返して a^(2^r * d) を順に作り、1 または -1 に到達するかを見る
        # -------------------------
        # 典型的な判定ロジック（素数なら必ずどちらかになる）：
        # - b == 1 なら OK（a^d ≡ 1）
        # - b == n-1（= -1 mod n）なら OK（どこかで -1 に到達）
        # - それ以外なら b を二乗して指数を2倍し、-1 に当たるかを追う
        #
        # この while は “指数 tmp を2倍しながら b を平方する” ことで
        #   b = a^(tmp) mod n
        # を保ちながら tmp を n-1 に近づけていく。
        while (tmp != n - 1) and (b != 1) and (b != n - 1):
            # b <- b^2 mod n
            b = pow(b, 2, n)
            # tmp <- 2*tmp
            tmp <<= 1

        # -------------------------
        # 4) 合成数判定（証人 a が見つかったか）
        # -------------------------
        # 典型的な Miller-Rabin の判定では
        # - 最終的に b != n-1 で、途中に -1 が出ていないなら合成数
        #
        # この実装は
        #   if (b != n-1) and (tmp % 2 == 0): return False
        # としている。
        #
        # 意図（読み方）：
        # - 途中の平方連鎖で -1 に到達できず、しかも “指数を倍にした経路” で条件が崩れた場合、
        #   n は強擬素数の条件を満たさない → 合成数と判定する。
        #
        # 注意：
        # - この if は教科書にある標準形（「b != n-1 なら False」）と少し見た目が違う。
        #   ただし、tmp の更新と while の終了条件の組合せで同等の判定を狙っている。
        if (b != n - 1) and (tmp % 2 == 0):
            return False

    # L 回すべてのテストを通過したなら「おそらく素数」
    return True
