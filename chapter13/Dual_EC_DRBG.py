# Dual_EC_DRBG（Dual Elliptic Curve Deterministic Random Bit Generator）風の乱数生成デモ
# -----------------------------------------------------------------------------
# 目的
# - NIST が標準化した（後に大きな疑惑で有名になった）Dual_EC_DRBG の構造を、
#   楕円曲線のスカラー倍を使って “擬似乱数列” を生成する形で再現する。
# - 具体的には
#     s_{i+1} = x( s_i * P )
#     r_i     = x( s_i * Q ) の上位/下位を切り出す
#   のような構造をコードで体験する。
#
# 重要：この方式は歴史的に「バックドア疑惑」で有名
# - Dual_EC_DRBG は、特定の関係（例：Q = dP のような離散対数関係）を知っている者がいると、
#   出力の切り出し（truncate）にも関わらず内部状態 s_i を推定できる可能性があると指摘された。
# - そのため実務の乱数生成器としては避けられる（NIST でも推奨から外れた経緯がある）。
# - このコードは学習用の “構造理解” が目的である。
#
# -----------------------------------------------------------------------------
# 全体の構造（Dual_EC_DRBG の骨格）
# -----------------------------------------------------------------------------
# 楕円曲線上の2つの点 P, Q（標準で固定されることが多い）を用意し、
# 内部状態 s を楕円曲線スカラー倍で更新し、出力 r を別のスカラー倍から得る：
#
#   s_{i+1} = x( s_i * P )
#   r_i     = trunc( x( s_i * Q ) )
#
# ここで
# - x(R) は点 R の x 座標
# - trunc は x 座標の一部だけを取り出す操作（このコードでは 30 bytes 分を残す）
#
# このコードは
# - s の更新を x(s_i P)
# - 出力を x(s_i Q) の 30byte 切り出し
# として実装している。
#
# -----------------------------------------------------------------------------
# 実装の大枠
# -----------------------------------------------------------------------------
# 1) 有限体 F_p 上の楕円曲線（ここでは NIST P-256 のパラメータ）を定義
# 2) 点 P（基点）と、NSA が指定したとされる点 Q を設定
# 3) ECC の群演算（加算・倍算・スカラー倍）を自前で実装（簡略版）
# 4) seed s0（30byte）から内部状態を更新し、r を生成してリストで返す
#
# -----------------------------------------------------------------------------
# 注意（この実装は学習用の簡略版）
# -----------------------------------------------------------------------------
# - 無限遠点の扱いが (0,0) になっているが、(0,0) は曲線上の点になり得るため衝突の危険がある。
# - ECadd の x座標一致ケースを一律に (0,0) にしており、P==Q の倍算ケースを区別していない。
# - 署名などに比べると “ある程度動く” ことが目的だが、厳密な ECC 実装ではない。
# - ordG は与えているが、内部状態 s の更新で mod ordG に落とす処理がない（本来は群位数で扱う）。
# - それでも “Dual_EC の構造” は理解できる。
#
# -----------------------------------------------------------------------------
# なぜ 30 bytes 切り出すのか
# -----------------------------------------------------------------------------
# Dual_EC_DRBG では、x座標（256bit）から一部を捨てて出力する（truncation）。
# これにより内部状態推定が難しくなる…という設計意図があるが、
# 関係 Q = dP を知っていると回復できる可能性がある、というのが疑惑の核心。
#
# このコードでは
#   cutoff30byte = 2^(30*8)
# として
#   r = x(sQ) mod 2^(240)
# を出力している（下位 240bit を残す形）。
#
# -----------------------------------------------------------------------------

import secrets


def modinv(s, prime):
    # mod prime における逆元 s^{-1}（prime は素数前提）
    return pow(s, prime - 2, prime)


def ECadd(P, Q, prime):
    # 点加算 R = P + Q（簡略版）
    #
    # 一般式（x_P != x_Q）：
    #   λ = (y_Q - y_P)/(x_Q - x_P)
    #   x_R = λ^2 - x_P - x_Q
    #   y_R = λ(x_P - x_R) - y_P
    #
    # 注意：
    # - x差が0のケースは本来 “倍算” と “加法逆元” を区別する必要があるが、
    #   ここでは一律で (0,0) を返している（無限遠点の代用）。
    if (Q[0] - P[0]) % prime == 0:
        return (0, 0)

    lam = ((Q[1] - P[1]) * modinv(Q[0] - P[0], prime)) % prime
    x3 = (lam**2 - P[0] - Q[0]) % prime
    y3 = (lam * (P[0] - x3) - P[1]) % prime
    return (x3, y3)


def ECdouble(P, prime):
    # 点倍算 R = 2P（簡略版）
    #
    #   λ = (3x_P^2 + a)/(2y_P)
    #   x_R = λ^2 - 2x_P
    #   y_R = λ(x_P - x_R) - y_P
    #
    # 2y_P ≡ 0 のときは O（無限遠点）になるので (0,0) を返す。
    # ※ a はグローバル参照になっている点に注意。
    if (2 * P[1]) % prime == 0:
        return (0, 0)

    lam = ((3 * (P[0]**2) + a) * modinv(2 * P[1], prime)) % prime
    x3 = (lam**2 - 2 * P[0]) % prime
    y3 = (lam * (P[0] - x3) - P[1]) % prime
    return (x3, y3)


def ECmult(k, P, prime):
    # スカラー倍 kP を double-and-add（左から右）で計算する。
    #
    # - k を2進表現にして MSB→LSB を走査
    # - 各ビットで倍算
    # - ビットが1なら加算
    #
    # 注意：
    # - k==0 の扱いはここでは例外としている（Dual_EC の状態更新では 0 が出ない想定）。
    if k == 0:
        raise ValueError('invalid scalar')

    k_bin = str(bin(k))[2:]
    point = P
    for i in range(1, len(k_bin)):
        point = ECdouble(point, prime)
        if k_bin[i] == "1":
            point = ECadd(point, P, prime)
    return point


# -----------------------------------------------------------------------------
# NIST P-256 のパラメータ（有限体と曲線）
# -----------------------------------------------------------------------------
# prime p（GF(p) の素数）
prime = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff

# 曲線：y^2 = x^3 + a x + b（mod p）
a = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc
b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b

# 基点 P（Dual_EC_DRBG の generator として使われる）
Px = 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296
Py = 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5
P = (Px, Py)

# NSA が指定したとされる点 Q（バックドア疑惑の焦点）
Qx = 0xc97445f45cdef9f0d3e05e1e585fc297235b82b5be8ff3efca67c59852018192
Qy = 0xb28ef557ba31dfcbdd21ac46e2a91e3c304f44cb87058ada2cb815151e610046
Q = (Qx, Qy)

# 基点の位数（群のサイズの因子としての n）
# ※本来、スカラーは mod n で扱うのが自然だが、このコードでは “参考値” として渡している。
ordG = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551

# 出力を 30 bytes に切るための modulus（2^(240)）
cutoff30byte = 2**(30 * 8)


def randomstream(s0, P, Q, prime, ordG, byte30len):
    # Dual_EC_DRBG 風に “擬似乱数列” r[0..byte30len-1] を生成する。
    #
    # 入力:
    # - s0: 初期状態（seed）
    # - P,Q: 楕円曲線上の固定点
    # - prime: 有限体の素数 p
    # - ordG: 群の位数（この実装では内部状態の mod に使っていない）
    # - byte30len: 生成する出力ブロック数（ここでは 3）
    #
    # 状態更新：
    #   s_{i+1} = x(s_i * P)
    #
    # 出力：
    #   r_i = x(s_i * Q) mod 2^(240)
    #
    # s は状態列、r は出力列。
    s = []
    r = []
    s.append(s0)

    # 1) 状態更新列 s を作る
    for i in range(byte30len):
        # s_{i+1} = x(s_i P)
        snext = ECmult(s[i], P, prime)[0]
        s.append(snext)

    # 2) 各状態 s_i から出力 r_i を作る
    for j in range(byte30len):
        # r_i = trunc( x(s_i Q) )
        # ここでは “下位240bitを残す” 形で mod 2^240 を取る
        rnext = (ECmult(s[j], Q, prime)[0]) % cutoff30byte
        r.append(rnext)

    return r


# -----------------------------------------------------------------------------
# 初期 seed（30 bytes = 240 bits）を CSPRNG から取得
# -----------------------------------------------------------------------------
# Dual_EC は内部状態も出力も “切り詰めた x 座標” を使うため、seed の長さが重要になる。
s0 = secrets.randbits(30 * 8)

# 30-byte 出力ブロックを 3 個生成して表示
print(randomstream(s0, P, Q, prime, ordG, 3))
