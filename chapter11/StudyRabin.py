# Rabin 暗号方式（Rabin cryptosystem）の学習用実装
# -----------------------------------------------------------------------------
# Rabin 暗号の概要
# - 公開鍵: N = p*q（p, q は大きな素数）
# - 暗号化: C = M^2 mod N（平方剰余を取るだけなので非常に単純）
# - 復号  : C の平方根を mod p と mod q で求め、CRT で合成する
#
# 重要な性質（RSAとの関係）
# - Rabin は「暗号化が平方」なので高速だが、復号すると一般に平方根が 4 個出る。
#   つまり 1つの暗号文 C から 4 つの候補 M が復元され得る。
# - 復号を一意にするには「冗長性（marker/padding）」を埋め込み、
#   4候補のうち “正しい形式” を満たすものを選び出す必要がある。
#
# セキュリティ観点
# - Rabin の安全性（復号の困難さ）は「N の因数分解の困難さ」と同程度とされる（理論的に強い）。
# - ただし “素のRabin（冗長性なし）” は復号の曖昧性があるため、実用では必ずパディングが必要。
# - 本コードは学習用で、実務の標準パディング（ISO/IECやOAEP類似）ではない簡易マーカー方式。
#
# -----------------------------------------------------------------------------
# 実装の前提（とても重要）
# -----------------------------------------------------------------------------
# Rabin 復号を簡単にするため、p と q を
#   p ≡ 3 (mod 4), q ≡ 3 (mod 4)
# の形（Blum prime）にすることが多い。
#
# この条件があると、平方根計算が非常に簡単になる：
# - p ≡ 3 (mod 4) で C が平方剰余なら
#     M ≡ C^{(p+1)/4} (mod p)
#   が平方根の一つになる（Tonelli-Shanks不要の特別ケース）。
#
# ここで与えられている p, q はそのような “3 mod 4” の素数である前提の値。
# （もし 3 mod 4 でなければ pow(C, (p+1)//4, p) は正しい平方根を返さない）
#
# -----------------------------------------------------------------------------
# ライブラリ
# -----------------------------------------------------------------------------
# - secrets: 暗号用に安全な乱数（CSPRNG）を得るための標準ライブラリ
# - sympy  : 素数判定など（今回は randprimeforRabin で使用）
#
# 注意：
# - このコードでは randprimeforRabin を定義しているが、固定の p,q を使っているため実際には未使用。


import secrets  # for safe random
import sympy


def modinv(a, q):
    # modinv: a^{-1} mod q を返す（q が素数のとき）
    #
    # フェルマーの小定理：
    #   a^{q-1} ≡ 1 (mod q)  （a ≠ 0 mod q）
    # より
    #   a^{q-2} ≡ a^{-1} (mod q)
    #
    # したがって逆元は pow(a, q-2, q) で計算できる。
    #
    # 注意：
    # - これは q が素数であることが必要。
    # - a が q の倍数だと逆元は存在しない。
    return pow(a, q - 2, q)


def randprimeforRabin(bits):
    # Rabin 向けに “3 mod 4” の素数（Blum prime）を生成する関数
    #
    # 目的：
    # - p ≡ 3 (mod 4) を満たす素数を得ると、平方根計算が簡単になる。
    #
    # 実装：
    # - bits ビットの乱数 r を生成
    # - r が素数（sympy.isprime）で、r%4==3 を満たすまで繰り返す
    # - さらに r が十分大きい（> 2^{bits-2}）ことをチェックしている
    #   （最上位ビットが立っていて “bits相当のサイズ” であることをある程度保証）
    flag = False
    while flag == False:
        r = secrets.randbits(bits)
        s = r % 4
        l = r > pow(2, bits - 2)
        flag = sympy.isprime(r) and (s == 3) and (l == True)
    return r


# -----------------------------------------------------------------------------
# 1) 鍵（公開法 N）
# -----------------------------------------------------------------------------
# p,q は大きな素数（Blum prime であることが望ましい）
p = 10668146672284242648113968657477864106029746819131668461088077577534582859503623765503498917678634018174964112824471991368886988139410203520593104027481883
q = 10787825398945465882072403800603236458752887238245891619468420367552159458144940803270285400388763643889830559249970593715694716373466123509073014764961059

# 公開鍵 N
N = p * q


def RabinEnc(M, N):
    # Rabin 暗号化
    #
    # 公開鍵 N に対して
    #   C = M^2 mod N
    # を計算するだけ。
    #
    # 注意：
    # - これだけだと復号時に平方根が 4 個出て曖昧になる。
    # - そのため実運用では M に冗長性を埋め込む（後述）。
    return pow(M, 2, N)


def RabinDec(C, p, q, N):
    # Rabin 復号（平方根の復元）
    #
    # Rabin では C = M^2 mod N の “平方根” を求める必要がある。
    # N=pq なので、平方根計算は CRT を利用して
    #   mod p での平方根
    #   mod q での平方根
    # を合成して求める。
    #
    # 手順
    # 1) Cp = C mod p, Cq = C mod q
    # 2) Mp = sqrt(Cp) mod p, Mq = sqrt(Cq) mod q を求める
    #    ここで p≡3(mod4) なら Mp = Cp^{(p+1)/4} mod p が平方根になる
    # 3) CRT により (Mp, Mq) を組み合わせた解を mod N で 4 個作る
    #
    # なぜ 4 個になるか？
    # - mod p では平方根が ±Mp の 2 個
    # - mod q でも平方根が ±Mq の 2 個
    # - 組み合わせで 2×2=4 個の解が存在する

    # 1) 小さい法へ落とす
    Cp = C % p
    Cq = C % q

    # 2) p,q が 3 mod 4 のときの平方根計算（特別に簡単）
    Mp = pow(Cp, (p + 1) // 4, p)  # ≡ ±M (mod p) のどちらか
    Mq = pow(Cq, (q + 1) // 4, q)  # ≡ ±M (mod q) のどちらか

    # 3) CRT 合成の係数を作る
    # u = p^{-1} mod q, v = q^{-1} mod p
    # これで CRT の合成
    #   X = (Mq*u*p + Mp*v*q) mod N
    # の形が作れる（条件により mod p と mod q が狙った値になる）
    u = modinv(p, q)
    v = modinv(q, p)

    # 4) (±Mp, ±Mq) の 4 通りを CRT 合成する
    #
    # M1: ( Mp mod p,  Mq mod q)
    # M2: (-Mp mod p,  Mq mod q)
    # M3: ( Mp mod p, -Mq mod q)
    # M4: (-Mp mod p, -Mq mod q)
    #
    # ここで -Mp mod p は (p - Mp)、-Mq mod q は (q - Mq) と書ける。
    M1 = (Mq * u * p + Mp * v * q) % N
    M2 = (Mq * u * p + (p - Mp) * v * q) % N
    M3 = ((q - Mq) * u * p + Mp * v * q) % N
    M4 = ((q - Mq) * u * p + (p - Mp) * v * q) % N

    # 4 つの平方根候補を返す
    return [M1, M2, M3, M4]


def select(lst, marker, size):
    # 復号候補が 4 個ある中から「正しい形式」を満たすものを 1 つ選ぶ
    #
    # この実装では、M の下位 (size+1) ビット（実際は 2^{size+1} で mod を取っている）を見て
    #   M mod 2^{size+1} == marker
    # を満たす候補を “正しい平文” とみなす。
    #
    # ここで marker は例えば 16bit の全1（0xffff）など。
    # つまり「末尾に既知の固定ビット列を付けておく」ことで復号の曖昧性を解消する。
    #
    # 注意：
    # - marker のビット長と mod の取り方（size+1）は設計として揃える必要がある。
    # - 実運用のパディング方式では、このような単純マーカーではなく
    #   より厳密な冗長性・ランダム性を使う。
    for i in range(4):
        if (lst[i] % pow(2, size + 1) == marker):
            return lst[i]


# -----------------------------------------------------------------------------
# 2) メッセージ（平文）を “復号一意化” できる形式に埋め込む
# -----------------------------------------------------------------------------
message = 123456

# marker: 16bit の全1（0xffff）
marker = pow(2, 16) - 1

# サイズ想定（ここでは説明用の変数。実際の p,q のビット長に一致しているとは限らない）
sizeofN = 1024
halfsizeofN = 512

# 平文 M のフォーマット（コメントの意図）
#   256bit random || message || marker(16bit)
#
# - 上位側にランダムを入れて “毎回異なる平文” にする（同じ message でも暗号文が変わる）
# - 下位側に marker を入れて、復号候補 4 個のうち正しいものを識別する
#
# 実装：
# - secrets.randbits(255) を上位 256bit 位置へ（*2^256）
# - message をさらにその下（*2^128）
# - marker を最下位へ
#
# ※ここで message は 128bit 幅に収まる前提の配置になっている。
M = secrets.randbits(255) * pow(2, 256) + message * pow(2, 128) + marker

# 平文を表示（hex）
print(hex(M))

# -----------------------------------------------------------------------------
# 3) 暗号化 → 復号（候補4つ）→ marker で選択
# -----------------------------------------------------------------------------
C = RabinEnc(M, N)           # 暗号文
lstM = RabinDec(C, p, q, N)  # 復号候補（4つの平方根）

# marker に一致する候補を選ぶことで平文を一意化
decodedM = select(lstM, marker, 16)

# 復号結果を表示
print(hex(decodedM))
