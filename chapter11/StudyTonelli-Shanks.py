# mod p における平方根（modular square root）を求める実装：modsqrt(a, p)
# -----------------------------------------------------------------------------
# 目的
# - 与えられた整数 a と奇素数 p に対して、
#
#     x^2 ≡ a (mod p)
#
# を満たす x（平方根）を 1 つ返す。
#
# これは暗号理論で頻出：
# - Rabin 暗号の復号
# - 楕円曲線暗号で y^2 = f(x) の平方根を求める
# - 2次剰余（quadratic residue）の判定と平方根復元
#
# -----------------------------------------------------------------------------
# 数学的背景
# -----------------------------------------------------------------------------
# 1) 平方剰余（Quadratic Residue）
# a が mod p で平方根を持つ（∃x: x^2≡a）ことを「平方剰余」と呼ぶ。
#
# 2) ルジャンドル記号 (a/p)
# 奇素数 p に対し、
#   (a/p) =  0  if a ≡ 0 (mod p)
#            1  if a is a quadratic residue mod p
#           -1  otherwise
#
# Euler の判定法：
#   a^{(p-1)/2} ≡ (a/p) (mod p)
# なので pow(a, (p-1)//2, p) で (a/p) が計算できる。
#
# 3) Tonelli–Shanks アルゴリズム
# p≡1(mod4) の一般ケースで平方根を計算する標準アルゴリズム。
# - p-1 = 2^s * t（t は奇数）に分解
# - 非平方剰余 v（Legendre(v,p)=-1）を探して g=v^t を作る
# - 反復で b の位数（order）を下げながら解 x を更新する
#
# このコードは “p≡3(mod4) の簡単ケース” と “Tonelli–Shanks の一般ケース” を切り替えている。
#
# -----------------------------------------------------------------------------
# 実装の大枠
# -----------------------------------------------------------------------------
# modsqrt(a, p):
#   0) p==2 を特別扱い
#   1) Legendre(a,p) で平方根存在判定（-1なら存在しない）
#   2) a≡0 なら 0
#   3) p≡3(mod4) なら x = a^{(p+1)/4} mod p（超簡単）
#   4) それ以外（p≡1(mod4)）は Tonelli–Shanks で計算
#
# 注意
# - 平方根は一般に 2 個ある（x と p-x）。この関数はそのうち 1 個だけ返す。
# - p は素数であることが前提（合成数ではこの手法は成立しない）。
# - p は奇素数を主対象としている（p==2 は例外扱い）。
#
# -----------------------------------------------------------------------------
# ルジャンドル記号の計算
# -----------------------------------------------------------------------------
def Legendre(a, p):
    # Euler 判定法により
    #   L = a^{(p-1)/2} mod p
    # を計算する。
    # - L=0 -> a≡0
    # - L=1 -> QR
    # - L=p-1 -> -1 mod p -> QNR（非平方剰余）
    L = pow(a, (p - 1) // 2, p)
    if L == p - 1:
        L = -1  # 扱いやすいよう -1 に直す
    return L


# -----------------------------------------------------------------------------
# QNR（Quadratic Non-Residue: 非平方剰余）v を探す
# -----------------------------------------------------------------------------
def Find_QNR_v(p):
    # Tonelli–Shanks では「非平方剰余 v」が 1 つ必要になる。
    # これは Legendre(v,p) = -1 を満たす v。
    #
    # 最も素朴には v=2,3,4,... と試していけば必ず見つかる（半分は非平方剰余）。
    v = 2
    while Legendre(v, p) != -1:
        v += 1
    return v


def modsqrt(a, p):
    # mod p における平方根を 1 つ返す。
    # 返す x は x^2 ≡ a (mod p) を満たす。
    #
    # -------------------------
    # 0) p==2 は特別ケース
    # -------------------------
    # mod 2 では 0^2=0, 1^2=1 なので、a mod 2 の値自身が平方根になっていると考えられる。
    if p == 2:
        return a  # 厳密には a%2 を返すのが自然だが、ここでは学習用の簡略形

    # -------------------------
    # 1) 平方根が存在するか判定
    # -------------------------
    # Legendre(a,p)=-1 なら平方根は存在しない（平方非剰余）。
    if Legendre(a, p) == -1:
        raise Exception('sqrt does not exist')

    # a≡0 (mod p) のとき平方根は 0
    elif a % p == 0:
        return 0

    # -------------------------
    # 2) p≡3(mod4) の簡単ケース
    # -------------------------
    # p = 4k+3 のとき、
    #   x = a^{(p+1)/4} mod p
    # が平方根になることが知られている（Tonelli–Shanks不要）。
    elif p % 4 == 3:
        return pow(a, (p + 1) // 4, p)

    # -------------------------
    # 3) 一般ケース：Tonelli–Shanks（p≡1(mod4) 側）
    # -------------------------
    # まず p-1 を 2^s * t（t 奇数）に分解する。
    #
    #   p - 1 = 2^s * t
    #
    # s は 2 の指数（2-adic valuation）、t は奇数部分。
    t = p - 1
    s = 0
    while t % 2 == 0:
        t //= 2
        s += 1

    # 非平方剰余 v を探し、g = v^t mod p を作る。
    # g は 2^s 位の元（の性質を持つ）として反復更新に使われる。
    v = Find_QNR_v(p)
    g = pow(v, t, p)

    # x は解の候補。b は誤差（x^2 と a のズレ）を管理する値。
    #
    # x = a^{(t+1)/2} mod p
    # b = a^t mod p
    #
    # これらは Tonelli–Shanks の標準初期化：
    # - もし b==1 なら既に x^2≡a が成立しており終了。
    x = pow(a, (t + 1) // 2, p)
    b = pow(a, t, p)

    # r は “残りの 2 の指数” を表すカウンタ（最初は s）
    r = s

    # 反復で b の位数（order）を縮めていく。
    # 目標は b==1 にして終了し、そのときの x が平方根になる。
    while True:
        # bpow を b から始めて平方していき、
        # b^(2^m) ≡ 1 となる最小の m を探す（m=ord_{2}(b) 的な役割）。
        #
        # ここで r の範囲で探すのは、b が属する部分群のサイズが 2^r であるため。
        bpow = b
        m = 0
        for m in range(r):
            if bpow == 1:
                break
            bpow = pow(bpow, 2, p)

        # m==0 のとき b==1 なので、x が解になっている
        if m == 0:
            return x

        # w = g^{2^{r-m-1}} を作り、更新に使う。
        #
        # Tonelli–Shanks の更新式（標準形）：
        #   w = g^{2^{r-m-1}}
        #   g <- w^2
        #   x <- x*w
        #   b <- b*g
        #   r <- m
        #
        # 直感：
        # - b の位数が 2^m に下がるように補正を入れる
        # - r を m に更新して探索範囲を縮める
        w = pow(g, 2 ** (r - m - 1), p)
        g = pow(w, 2, p)
        x = (x * w) % p
        b = (b * g) % p
        r = m
