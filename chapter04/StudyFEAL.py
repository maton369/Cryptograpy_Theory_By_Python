# 64bitブロック暗号（学習用：Feistel型に近い構造）実装
# -----------------------------------------------------------------------------
# このコードは、64bit ブロック（x）を 32bit×2（L,R）に分割し、
# 4段（N=4）のラウンドを回して暗号化/復号する「小さめのブロック暗号」の実装である。
#
# 注意
# - アルゴリズム名が明示されていないが、構造としては Feistel 型（あるいはそれに類似）で、
#   F関数（f）と鍵スケジュール（keysched）を持つ。
# - S-box は 8bit 入力で単純な加算＋回転（rotl8）で構成されており、学習・演習向け。
# - 実務で安全な暗号（AES等）とは別物で、強度保証はない。
#
# 重要：データ表現
# - 32bit ワードを扱う箇所が多いので、Python の任意精度整数に対して
#   適宜 &0xffffffff や &0xff で桁を丸める（mod 2^32 / mod 2^8）が重要である。
#
# -----------------------------------------------------------------------------
# パラメータ
# -----------------------------------------------------------------------------
N = 4  # 段数（ラウンド数）
# N が増えるほど拡散は強くなる傾向があるが、ここでは 4 段固定で動作確認する。


def rotl8(a, n):
    # 8ビットデータ a を n ビット左回転（循環シフト）
    # - a は 0..255 の想定
    # - 結果も 8bit に丸めるため &0xff を入れている
    #
    # 例:
    #   a=0b10010000, n=2
    #   -> 0b01000010
    return (((a << n) | (a >> (8 - n))) & 0xff)


def s(a, b, d):
    # s0, s1 相当の “簡易S-box” 関数
    #
    # 引数
    # - a, b: 8bit 入力（0..255）
    # - d   : 0 または 1（s0 と s1 を切り替えるための定数ビット）
    #
    # 中身
    # - (a + b + d) mod 256 を計算してから 2bit 左回転する
    #
    # つまり「加算（mod 2^8）」と「回転」で非線形性・拡散っぽいものを作る意図がある。
    return rotl8((a + b + d) & 0xff, 2)


def fk(a, b):
    # 鍵スケジュール専用の Fk 関数
    #
    # 役割
    # - 32bit ワード a を、別の 32bit ワード b に依存した形で更新し、
    #   ラウンド鍵生成のための“混ぜ合わせ”を行う。
    #
    # 実装の読み方
    # - a を 8bit×4 のバイト列として扱い、バイト単位で s() を適用する。
    # - さらに、その s() の入力に b の各バイト（>>24, >>16, >>8, &0xff）を XOR 混入させる。
    #
    # ここで使っているテクニック
    # - (a & mask) | (new_byte << shift) で a の一部バイトだけを書き換える
    # - (a>>k)&0xff で a の特定バイトを取り出す
    # - b の対応バイトを XOR して鍵依存性を入れる

    # a のバイト配置を一部入れ替えるような操作（実質的なバイトシャッフル）
    # ((a>>24)<<16) は「最上位バイトを 16bit位置へ」
    # ((a&0xff)<<8) は「最下位バイトを 8bit位置へ」
    # これらを XOR することで a の内部バイトが混ざる（線形操作）
    a ^= (((a >> 24) << 16) ^ ((a & 0xff) << 8))

    # a の 2番目バイト（bit16..23）を更新
    # - 入力: a[2] と (a[1] XOR b[3]) と d=1
    #   b>>24 は b の最上位バイト（b[0]）に見えるが、ここでは参照の組み方が実装依存
    a = (a & 0xff00ffff) | (s(((a >> 16) & 0xff), ((a >> 8) & 0xff) ^ (b >> 24), 1) << 16)

    # a の 3番目バイト（bit8..15）を更新
    a = (a & 0xffff00ff) | (s(((a >> 8) & 0xff), ((a >> 16) & 0xff) ^ ((b >> 16) & 0xff), 0) << 8)

    # a の 1番目バイト（bit24..31）を更新
    a = (a & 0x00ffffff) | (s((a >> 24), ((a >> 16) & 0xff) ^ ((b >> 8) & 0xff), 0) << 24)

    # a の最下位バイト（bit0..7）を更新して返す
    return (a & 0xffffff00) | s((a & 0xff), ((a >> 8) & 0xff) ^ (b & 0xff), 1)


def f(a):
    # 暗号本体で使う F 関数
    #
    # 特徴
    # - fk に似ているが、入力 b を使わずに a 単体で変換する。
    # - 32bit ワード a をバイト単位で s() に通して非線形変換する。
    #
    # Feistel 型暗号では
    #   L, R を更新する際に F(R ⊕ K) のような形がよく出てくる。
    # このコードでもラウンドで r ^ k[i] を作って f に入れている。

    a ^= (((a >> 24) << 16) ^ ((a & 0xff) << 8))

    # a の各バイトを順に s() で更新（b入力が無いので a の他バイトだけを参照している）
    a = (a & 0xff00ffff) | (s(((a >> 16) & 0xff), ((a >> 8) & 0xff), 1) << 16)
    a = (a & 0xffff00ff) | (s(((a >> 8) & 0xff), ((a >> 16) & 0xff), 0) << 8)
    a = (a & 0x00ffffff) | (s((a >> 24), ((a >> 16) & 0xff), 0) << 24)

    return (a & 0xffffff00) | s((a & 0xff), ((a >> 8) & 0xff), 1)


def keysched(key):
    # 鍵スケジュール
    #
    # 入力
    # - key: 64bit 整数（ここでは 0x123456789abcdef0 など）
    #
    # 出力
    # - k: ラウンド鍵の配列（長さ N+2）
    #
    # なぜ N+2 個？
    # - 本体の ciph() では、暗号化時に
    #     (最後に XOR する鍵) が 2 個（k[N], k[N+1]）
    #   必要になっているため。
    #
    # 変数の意味
    # - kl, kr: 32bit×2 に分割した key（左/右）
    # - kx    : 直前の値を保持して混ぜるためのワーク（簡易なフィードバック）
    k = []
    kl, kr, kx = (key >> 32), (key & 0xffffffff), 0

    # i=0..N+1 の合計 N+2 回、鍵を更新して k に push していく
    for _i in range(N + 2):
        # 更新の流れ（ざっくり）
        # - kl,kr を入れ替えつつ
        # - fk(kl, (kr XOR kx)) を使って新しい kr を作る
        # - kx に古い kl を入れる（フィードバック）
        kl, kr, kx = kr, fk(kl, (kr ^ kx)), kl

        # 生成した kr をラウンド鍵として保存
        k.append(kr & 0xffffffff)  # 32bit に丸めておくと安全

    return k


def ciph(x, k, ed):
    # 暗号化/復号処理
    #
    # 入力
    # - x : 64bit ブロック（整数）
    # - k : ラウンド鍵配列（keysched の出力）
    # - ed: 0=暗号化, 1=復号
    #
    # 出力
    # - 64bit ブロック（暗号文 or 平文）
    #
    # 構造
    # - 64bit を (L,R) 32bit×2 に分割し、N 段のラウンドを回す。
    # - ラウンドでは f( R XOR round_key ) を使って L を更新する形になっている。
    #
    # 復号について
    # - Feistel 型に近いので、ラウンド鍵を逆順に使えば復号できる（このコードもそうしている）。
    # - ただし入出力の前後処理（k[N],k[N+1] の XOR）もあるので、
    #   そこも暗号化/復号で左右対称になるよう実装されている。

    if ed:
        # 復号側の初期化
        # - 暗号化の最後に XOR した k[N], k[N+1] を最初に戻すためにここで XOR する
        l = (x >> 32) ^ k[N]
        r = (x & 0xffffffff) ^ k[N + 1]
    else:
        # 暗号化側の初期化（そのまま分割）
        l = (x >> 32)
        r = (x & 0xffffffff)

    # ここで r = l XOR r としているのは、この暗号のラウンド構造に合わせた前処理。
    # 最終でも (l XOR r) の形で戻すので、両端で対称性を取っている。
    r = (l ^ r) & 0xffffffff
    l &= 0xffffffff

    # N ラウンド
    for i in range(N):
        # 暗号化時: round_key = k[i]
        # 復号時  : round_key = k[N-1-i]（逆順）
        rk = (k[N - 1 - i] if ed else k[i])

        # ラウンド更新
        #   (l, r) = (r, l XOR f(r XOR rk))
        #
        # 典型的な Feistel 更新に似ている：
        #   L_{i+1} = R_i
        #   R_{i+1} = L_i XOR F(R_i, K_i)
        #
        # ここでは F に入れる前に (r XOR rk) を作っている。
        l, r = r, (l ^ f((r ^ rk) & 0xffffffff)) & 0xffffffff

    # 出力合成
    # - 復号/暗号化で前後処理（k[N],k[N+1] XOR）の位置が異なるように見えるが、
    #   全体として対称になるよう式が組まれている。
    if ed:
        # 復号: 仕上げは (r<<32) | (l XOR r)
        return ((r << 32) | (l ^ r)) & 0xffffffffffffffff
    else:
        # 暗号化: 仕上げで k[N], k[N+1] を XOR する
        #   上位32: (r XOR k[N])
        #   下位32: (l XOR r) XOR k[N+1]
        return (((r ^ k[N]) << 32) | ((l ^ r) ^ k[N + 1])) & 0xffffffffffffffff


# -----------------------------------------------------------------------------
# 動作確認
# -----------------------------------------------------------------------------
key = 0x123456789abcdef0
k = keysched(key)                   # 鍵スケジュール
txt = 0xd228f5f79b5da362            # 平文（64bit）
ctx = ciph(txt, k, 0)               # 暗号化
print(format(ctx, '016x'), format(ciph(ctx, k, 1), '016x'))  # 暗号文と復号結果
