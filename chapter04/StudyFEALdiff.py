# 差分解読法を用いた FEAL-4 における K3 の導出テストプログラム
# (Differential Attack for FEAL4 (K3))
# -----------------------------------------------------------------------------
# これは「FEAL-4（4ラウンドの FEAL）」に対して、差分解読（Differential Cryptanalysis）
# の考え方を使い、ラウンド鍵 K3（ここでは k[3]）に関係する部分鍵候補を絞り込む
# 学習用デモプログラムである。
#
# 重要: これは「攻撃アルゴリズムを理解する」ためのコードであり、
# 実務の暗号強度を保証するものではない（FEAL は古典暗号で既に破られている側）。
#
# -----------------------------------------------------------------------------
# 0. 差分解読の大枠（何をやっているか）
# -----------------------------------------------------------------------------
# 差分解読は次の手順で進むことが多い:
#
# (1) 平文ペア (P, P⊕Δ) を多数用意し、暗号化して暗号文ペア (C, C⊕ΔC) を得る
# (2) 暗号の内部（最終ラウンド付近）で成立しやすい差分関係を利用し、
#     「ある部分鍵を仮定したときにのみ成り立つ条件」を作る
# (3) 部分鍵を総当たりし、条件に合う回数が多い（または全ペアで合う）候補を残す
#
# このコードでは二段階の絞り込みをしている:
#
# Step A: (a0,a1)（16bit）を探索
#   - 2^16 全探索し、全ペアで成立する a01 を探す
#
# Step B: (k0,k3)（16bit）を探索（Step A の候補ごと）
#   - 2^16 全探索し、全ペアで成立する候補を探す
#
# 最後に「真の k[3]」を表示して、候補に真値が含まれているか確認する。
#
# -----------------------------------------------------------------------------
# 1. 実装されている FEAL-4（簡略）について
# -----------------------------------------------------------------------------
# - ブロック長: 64bit（L||R の 32bit×2）
# - ラウンド数: N=4
# - ラウンド関数: f(32bit) -> 32bit （内部は 8bit S-box s() を利用）
# - 鍵スケジュール: fk() を回して k[0..N+1] を生成（合計 N+2 個）
#
# ※本コードの ciph は「暗号化だけ」を実装している（ed 引数があるが使っていない）。
#   差分攻撃のデモなので暗号化だけあれば十分、という設計である。


import random

# FEAL-4 のラウンド数
N = 4  # 段数（ラウンド数）


def rotl8(a, n):
    # 8ビットデータ a の n ビット左回転（循環シフト）
    # - a は 0..255 を想定
    # - &0xff で 8bit に丸める
    return ((((a) << (n)) | ((a) >> (8 - (n)))) & 0xff)


def s(a, b, d):
    # FEAL の s0/s1 に相当する “簡易S-box”
    # - 入力: 8bit a, 8bit b, 1bit d（0 or 1）
    # - 出力: rotl8( (a+b+d) mod 256, 2 )
    #
    # 差分解読では、この S-box 的な非線形部が「差分の伝播」に重要になる。
    return rotl8(((a) + (b) + d) & 0xff, 2)


def fk(a, b):
    # 鍵スケジュールで用いる Fk 関数（32bitワード a を b 依存で混ぜる）
    #
    # 実装の見方:
    # - a を 8bit×4 に分解して s() を適用し、a の各バイトを書き換える
    # - 書き換え時に b の各バイトを XOR 混入して鍵依存性を入れる
    #
    # ここでの XOR/シフトは「バイトシャッフル + 混合」に相当する操作。
    a ^= (((a >> 24) << 16) ^ ((a & 0xff) << 8))

    # a の 2番目バイト（bit16..23）を更新
    a = (a & 0xff00ffff) | (s(((a >> 16) & 0xff), ((a >> 8) & 0xff) ^ ((b) >> 24), 1) << 16)

    # a の 3番目バイト（bit8..15）を更新
    a = (a & 0xffff00ff) | (s(((a >> 8) & 0xff), ((a >> 16) & 0xff) ^ (((b) >> 16) & 0xff), 0) << 8)

    # a の 1番目バイト（bit24..31）を更新
    a = (a & 0x00ffffff) | (s((a >> 24), ((a >> 16) & 0xff) ^ (((b) >> 8) & 0xff), 0) << 24)

    # 最下位バイト（bit0..7）を更新して返す
    return (a & 0xffffff00) | s((a & 0xff), ((a >> 8) & 0xff) ^ ((b) & 0xff), 1)


def f(a):
    # 暗号本体で用いる F 関数（32bit -> 32bit）
    #
    # fk() と似た形だが、こちらは “鍵 b を混ぜない”。
    # ラウンドでは f(r ^ k[i]) の形で鍵を混ぜてから f に通す（典型的構造）。
    a ^= (((a >> 24) << 16) ^ ((a & 0xff) << 8))

    # バイト単位の s() 適用で 32bit を非線形変換する
    a = (a & 0xff00ffff) | (s(((a >> 16) & 0xff), ((a >> 8) & 0xff), 1) << 16)
    a = (a & 0xffff00ff) | (s(((a >> 8) & 0xff), ((a >> 16) & 0xff), 0) << 8)
    a = (a & 0x00ffffff) | (s((a >> 24), ((a >> 16) & 0xff), 0) << 24)

    return (a & 0xffffff00) | s((a & 0xff), ((a >> 8) & 0xff), 1)


def keysched(key, k):
    # 鍵スケジュール
    #
    # 入力:
    # - key: 64bit（ここでは固定値）
    # - k  : ラウンド鍵を append するリスト（参照渡し）
    #
    # 出力:
    # - k: 長さ N+2 の 32bit ラウンド鍵列
    #
    # 仕組み:
    # - 64bit key を 32bit×2（kl,kr）に分割
    # - (kl,kr,kx) を更新しながら fk() を使って kr を生成し、k に詰める
    kl, kr, kx = (key >> 32), (key & 0xffffffff), 0

    for i in range(N + 2):
        # ここで kx をフィードバックとして混ぜることで、鍵の拡散を狙う
        kl, kr, kx = kr, fk(kl, (kr ^ kx)), kl
        k.append(kr & 0xffffffff)  # 32bitに丸めて保存

    return k


def ciph(txt, k, ed):
    # 暗号化処理（Feistel風）
    #
    # 入力:
    # - txt: 64bit 平文
    # - k  : ラウンド鍵列（k[0..N+1] だが、この関数では k[0..N-1] だけ使用）
    # - ed : 本来は暗/復号切り替え用だが、この関数では未使用（常に暗号化）
    #
    # 出力:
    # - 64bit 暗号文
    #
    # 構造（要点）:
    # - 64bit を L,R に分割（各32bit）
    # - 前処理で r = l XOR r
    # - N ラウンド:
    #     (l, r) = (r, l XOR f(r XOR k[i]))
    # - 出力は (r << 32) | (l XOR r)
    #
    # ※ FEAL の実装としてこういう表現を取る流儀があり、差分解析用の “内部量” を
    #    取り出しやすい形になっている。
    l, r = (txt >> 32), (txt & 0xffffffff)
    l, r = l, l ^ r

    for i in range(N):
        l, r = r, l ^ f(r ^ k[i])

    return (r << 32) | (l ^ r)


def ma(x):
    # 関数 M(A) = (Z, a0 XOR a1, a2 XOR a3, Z) のような “差分攻撃用の線形写像”
    # （コメントの表記をそのまま解釈すると「先頭と末尾は0、中央はバイトXOR」の形）
    #
    # 実装を読む:
    # - ((x>>8)^x) & 0x00ff0000  は  (byte2 XOR byte1) を byte2位置に置くような操作
    # - (x^(x<<8)) & 0x0000ff00  は  (byte1 XOR byte0) を byte1位置に置くような操作
    #
    # つまり x の隣接バイト差分を取り出す線形操作になっている。
    return (((x >> 8) ^ x) & 0x00ff0000) | ((x ^ (x << 8)) & 0x0000ff00)


# -----------------------------------------------------------------------------
# 2. 差分攻撃のパラメータ設定
# -----------------------------------------------------------------------------

M = 10  # ペア数（差分条件が M 個すべてで成立する候補だけ残す）
# M を増やすほど「偶然当たる候補」が減り、真の鍵候補が浮かびやすくなるが計算量は増える。

key = 0x4b4559424c4f434c  # 64bit 鍵（固定）
k = []                   # ラウンド鍵リスト
keysched(key, k)         # k[0..N+1] を生成（ここでは k[3] が真の K3）

# 選ぶ平文差分 Δ（delta）
# - 差分解読では「特定の差分が内部で高確率に特定の差分へ写る」性質を利用する。
# - ここでは Δ = 0x8080000080800000 を使っている。
delta = 0x8080000080800000

# 平文ペア / 暗号文ペアの格納
txt = [[0, 0] for i in range(M)]  # txt[i] = [P, P⊕Δ]
ctx = [[0, 0] for i in range(M)]  # ctx[i] = [C, C']

# 差分攻撃で使う内部量
y0 = [0 for i in range(M)]  # Y0（暗号文から計算する中間）
y1 = [0 for i in range(M)]  # Y1
zd = [0 for i in range(M)]  # Z'（差分条件の右辺に使う量）

# Step A 用の集計テーブル
# - j は 0..65535（=2^16）で、(a0,a1) の候補を表す
# - counta[j] は「条件に合ったペア数」を数える
counta = [0 for i in range(65536)]

# (a0,a1) の候補のリスト（counta[j]==M のものを入れる）
a = []


# -----------------------------------------------------------------------------
# 3. Step A: (a0,a1) を 2^16 全探索して絞り込み
# -----------------------------------------------------------------------------
# 各ペア i について:
# - ランダム P を作り、P' = P⊕Δ を作る
# - C = E(P), C' = E(P') を得る
# - 暗号文から y0,y1, z' を作る
# - すべての a01(16bit) を試し、差分条件が成立するものを counta に加点
#
# 差分条件:
#   Q0 = f( M(y0) XOR a01 )
#   Q1 = f( M(y1) XOR a01 )
#   そして「Q0 XOR Q1 の特定ビット範囲」が z' の特定範囲と一致するかを見る。
#
# ここでは
#   (((q0^q1)>>8)&0xffff) == ((zd>>8)&0xffff)
# を判定しているので、bit8..23 の 16bit が一致する条件である。

for i in range(M):
    # 64bit の平文 P をランダム生成
    txt[i][0] = random.randint(0, (1 << 64) - 1)

    # 差分 Δ を持つ相方 P' を作る
    txt[i][1] = txt[i][0] ^ delta

    # 暗号化して暗号文ペア (C, C')
    ctx[i][0] = ciph(txt[i][0], k, 0)
    ctx[i][1] = ciph(txt[i][1], k, 0)

    # C を 32bit×2 (L,R) に分割
    l0, r0 = (ctx[i][0] >> 32), (ctx[i][0] & 0xffffffff)
    l1, r1 = (ctx[i][1] >> 32), (ctx[i][1] & 0xffffffff)

    # FEAL 差分攻撃でよく使う内部量の例:
    # Y = L XOR R の形（この暗号の出力形式に合わせている）
    y0[i] = l0 ^ r0
    y1[i] = l1 ^ r1

    # Z' の構成:
    # (l0 ^ l1) は暗号文左半分の差分 ΔL
    # さらに 0x02000000 を XOR している（理論上の補正/期待差分）
    # ※この “補正値” は差分特性を成立させるための定数として登場することが多い。
    zd[i] = (l0 ^ l1) ^ 0x02000000

    # (a0,a1) 16bit 全探索（2^16）
    # j は 0..65535
    # a01 = j << 8 としているので、a01 は 32bit のうち “特定バイト位置” に置かれる形。
    #
    # この「<<8」の理由は、ma(y) の結果が中央寄りのバイト位置に値を持つ作りなので、
    # XOR する相手も同じ位置に配置して差分条件を評価するため。
    for j in range(65536):
        a01 = j << 8

        # Q0, Q1 を計算
        q0 = f(ma(y0[i]) ^ a01)
        q1 = f(ma(y1[i]) ^ a01)

        # 差分条件: Q0 XOR Q1 の bit8..23 が Z' の bit8..23 と一致するか？
        if (((q0 ^ q1) >> 8) & 0xffff) == ((zd[i] >> 8) & 0xffff):
            counta[j] += 1


# Step A の結果: 全 M ペアで一致した (a0,a1) を候補として採用
l = 0  # 候補数

for i in range(65536):
    if counta[i] == M:
        a.append(i)  # 16bit 候補として保存
        print("(a0,a1)=", format(i, '04x'))
        l += 1


# -----------------------------------------------------------------------------
# 4. Step B: (k0,k3) を 2^16 全探索してさらに絞り込み（a候補ごと）
# -----------------------------------------------------------------------------
# Step A で得た a[j]（=a0,a1 の候補）ごとに、
# 次は 16bit の別パラメータ c を総当たりし、そこから D を構成する。
#
# d の作り:
#   d = ((c<<16)&0xff000000) | ((c^a)<<8) | (c&0xff)
#
# これは “32bit の特定バイト配置” を意図しており、
# 32bit 変数 d の各バイトが (k0, k0^a0, k3^a1, k3) のような関係を持つよう設計されている
# （print でその形を出して確認している）。
#
# 判定条件:
#   z0b = f(y0 ^ d)
#   z1b = f(y1 ^ d)
#   z0b XOR z1b == Z'
#
# これが全 M ペアで成立する c を候補として残す。

kc = []  # （このコードでは最終的に使っていないが、鍵候補を貯めるならここ）

for j in range(l):
    # c の集計表（2^16）
    countc = [0 for i in range(65536)]

    for i in range(M):
        for c in range(65536):
            # d を組み立てる（32bit）
            # - 上位バイト（bit24..31）に c の上位8bit を入れる
            # - 中央（bit8..23）には (c XOR a[j]) を入れる（a の影響を注入）
            # - 下位バイト（bit0..7）に c の下位8bit を入れる
            d = ((c << 16) & 0xff000000) | ((c ^ a[j]) << 8) | (c & 0xff)

            # 候補 d を使って “逆方向のような” 量を作る（ここが差分攻撃のコア）
            z0b = f(y0[i] ^ d)
            z1b = f(y1[i] ^ d)

            # 差分一致判定
            if (z0b ^ z1b) == zd[i]:
                countc[c] += 1

    # 全 M ペアで一致した c を候補として出力
    for i in range(65536):
        if countc[i] == M:
            # i は 16bit 候補（便宜上 (k0,k1) と表示しているが、ここは命名が実験由来）
            print("(k0,k1)=", format(i, '04x'))

            # 「(k0, k0^a0, k3^a1, k3)」の形を表示して、
            # 真値と一致するものがあるかを目視確認するための出力
            #
            # - i>>8 は上位8bit（k0相当）
            # - a[j]^i は 16bit（k0,k3 と a0,a1 の関係を見るため）
            # - i&0xff は下位8bit（k3相当）
            print(
                "(k0,k0^a0,k3^a1,k3)=",
                format(i >> 8, '02x'),
                format(a[j] ^ i, '04x'),
                format(i & 0xff, '02x')
            )

# 最後に真の k3（k[3]）を表示して、候補に一致するものがあるか確認する
print("k3 = ", format(k[3], '08x'))
