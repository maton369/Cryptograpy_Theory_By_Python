# FEAL-4 における線形解読（Linear Cryptanalysis）による K0 の導出テストプログラム
# -----------------------------------------------------------------------------
# このプログラムは、FEAL-4（4ラウンド）に対して線形解読法を適用し、
# 第1ラウンド鍵 K0（コード上は k[0]）を候補として導出できることを確認する学習用コードである。
#
# 重要：これは「線形解読の手順」を理解するためのデモであり、実務的な暗号強度を示すものではない。
# FEAL は歴史的に線形/差分解読で破られたことで有名な暗号である。
#
# -----------------------------------------------------------------------------
# 0. 線形解読の大枠（何をしているか）
# -----------------------------------------------------------------------------
# 線形解読では、暗号内部で「確率的に偏りを持つ線形式」を利用する。
# 典型的には次の流れになる：
#
# (1) 平文 P と暗号文 C のペアを大量に集める（ここでは M=1000）
# (2) 暗号の内部状態に関する線形式
#       L(P, C) ⊕ L'(K) = 0
#     が、ランダムよりも高い確率（偏り）で成立することを使う
# (3) 部分鍵を仮定して線形式を評価し、成立回数が偏る候補を「正しい鍵らしい」と判断する
#
# ただしこのコードは統計的な「多数決」ではなく、
#   - count[0] と count[1] が両方とも非ゼロになったら即失格（break）
#   - つまり「全サンプルで同じ値（0または1）にならない候補は捨てる」
# という非常に強いフィルタになっている。
# これは「式(4.24)〜(4.28)が（ほぼ）決定的に成り立つ状況」を想定したテスト用である。
#
# -----------------------------------------------------------------------------
# 1. FEAL-4 実装（暗号化に必要な最小部品）
# -----------------------------------------------------------------------------
# - rotl8, s : 8bit の回転 + 加算による簡易S-box（s0/s1）
# - fk       : 鍵スケジュール用の混合関数
# - f        : ラウンド関数（32bit -> 32bit）
# - keysched : 64bit key からラウンド鍵 k[0..N+1] を生成（長さ N+2）
# - ciph     : FEAL-4 の暗号化（Whitening込みの出力形式）
#
# ここで N=4 なので、ラウンド鍵は k[0],k[1],k[2],k[3] がラウンドで使われ、
# さらに出力のホワイトニングに k[4],k[5]（=k[N],k[N+1]）が使われる。


import random

N = 4  # 段数（ラウンド数）


def rotl8(a, n):
    # 8bit データ a を nbit 左回転（循環シフト）
    return ((((a) << (n)) | ((a) >> (8 - (n)))) & 0xff)


def s(a, b, d):
    # s0, s1 ボックス（簡易S-box）
    # s(a,b,d) = rotl8((a+b+d) mod 256, 2)
    # d=0 が s0、d=1 が s1 の切り替えに相当
    return rotl8(((a) + (b) + d) & 0xff, 2)


def fk(a, b):
    # 鍵スケジュールで用いる Fk 関数
    # 32bit ワード a をバイト単位で s() に通しつつ、b の各バイトを XOR 混入させて拡散する。
    a ^= (((a >> 24) << 16) ^ ((a & 0xff) << 8))
    a = (a & 0xff00ffff) | (s(((a >> 16) & 0xff), ((a >> 8) & 0xff) ^ ((b) >> 24), 1) << 16)
    a = (a & 0xffff00ff) | (s(((a >> 8) & 0xff), ((a >> 16) & 0xff) ^ (((b) >> 16) & 0xff), 0) << 8)
    a = (a & 0x00ffffff) | (s((a >> 24), ((a >> 16) & 0xff) ^ (((b) >> 8) & 0xff), 0) << 24)
    return (a & 0xffffff00) | s((a & 0xff), ((a >> 8) & 0xff) ^ ((b) & 0xff), 1)


def f(a):
    # FEAL のラウンド関数 F（32bit -> 32bit）
    # 鍵混入は呼び出し側で r^k[i] を作ってからこの f に入れる。
    a ^= (((a >> 24) << 16) ^ ((a & 0xff) << 8))
    a = (a & 0xff00ffff) | (s(((a >> 16) & 0xff), ((a >> 8) & 0xff), 1) << 16)
    a = (a & 0xffff00ff) | (s(((a >> 8) & 0xff), ((a >> 16) & 0xff), 0) << 8)
    a = (a & 0x00ffffff) | (s((a >> 24), ((a >> 16) & 0xff), 0) << 24)
    return (a & 0xffffff00) | s((a & 0xff), ((a >> 8) & 0xff), 1)


def keysched(key, k):
    # 鍵スケジュール：64bit key をもとに 32bit ラウンド鍵列 k を生成（長さ N+2）
    kl, kr, kx = (key >> 32), (key & 0xffffffff), 0
    for _i in range(N + 2):
        kl, kr, kx = kr, fk(kl, (kr ^ kx)), kl
        k.append(kr)
    return k


def ciph(txt, k, ed):
    # FEAL-4 暗号化（Whitening込みの出力）
    #
    # 入力：txt(64bit)
    # - L0 = txt>>32, R0 = txt&0xffffffff
    # - 前処理として R = L XOR R
    #
    # 4ラウンド：
    #   (l,r) = (r, l XOR f(r XOR k[i]))
    #
    # 出力（ホワイトニング）：
    #   C = ( (r XOR k[N]) << 32 ) | ( (l XOR r) XOR k[N+1] )
    #
    # ※線形解読では「平文/暗号文の特定ビットの XOR」が偏る関係を使うため、
    #   出力形式（どこに k[N],k[N+1] が XOR されるか）が重要になる。
    l, r = (txt >> 32), (txt & 0xffffffff)
    l, r = l, l ^ r
    for i in range(N):
        l, r = r, l ^ f(r ^ k[i])
    return ((r ^ k[N]) << 32) | ((l ^ r) ^ k[N + 1])


def si(l, x):
    # si: “選択したビットの XOR（パリティ）” を返す関数
    #
    # 入力：
    # - l: ビット位置のリスト（0..31 の想定）
    # - x: 32bit 整数
    #
    # 出力：
    # - 指定ビットをすべて XOR した 0/1
    #
    # 実装の読み方：
    # - (x >> (31 - l[i])) & 1 で「MSBを31番」とする座標系で l[i] 番ビットを取り出す
    #   （仕様書や数式が MSB=0 として定義されていることが多いので、それに合わせた可能性が高い）
    a = 0
    for i in range(len(l)):
        a ^= ((x >> (31 - l[i])) & 1)
    return a


# -----------------------------------------------------------------------------
# 2. 実験設定（鍵とサンプル生成）
# -----------------------------------------------------------------------------
k = []

# 64bit の秘密鍵をランダム生成（毎回変わるので再現性が欲しければ seed を固定するとよい）
key = random.randint(0, (1 << 64) - 1)
keysched(key, k)

# 真の鍵を表示（答え合わせ用）
print("key　=", format(key, '016x'))
print("k0　=", format(k[0], '08x'))  # 真のラウンド鍵 K0

M = 1000  # 平文&暗号文ペア数（線形解読は基本的に「大量サンプル」が命）
txt = []
ctx = []

# M 個の (P, C=E(P)) を準備
for i in range(M):
    txt.append(random.randint(0, (1 << 64) - 1))
    ctx.append(ciph(txt[i], k, 0))


# -----------------------------------------------------------------------------
# 3. 線形解読の鍵探索（2段階）
# -----------------------------------------------------------------------------
# このコードは K0（32bit）をいきなり 2^32 全探索せず、次の2段階に分けている：
#
# Step 1: まず 14bit の総当たりで K0' を探索
#   コメントにある通り K0' は K0 の特定ビット集合の XOR によって構成される “圧縮表現”。
#   これを満たす候補だけを次段へ回す。
#
# Step 2: Step 1 を通った候補に対し、残り 18bit を総当たりして K0 を復元し、
#         さらに 4つの線形式（式(4.24)〜(4.27)）をすべて満たすものを出力する。
#
# ここで使う線形式は、コメント中の「式(4.24)〜(4.28)」に対応している。
# いずれも形としては
#   si( ... , (平文/暗号文の線形結合) ) XOR si( ... , f(内部 XOR 鍵候補) ) = 0/1
# のような “パリティの XOR” になっている。


# -----------------------------------------------------------------------------
# Step 1: 14ビット総当たりで K0' を探索
# -----------------------------------------------------------------------------
for j in range(1 << 14):
    # 14bit の j から 32bit の k0d（K0'）を構成する。
    #
    # ここは「どのビット位置に 14bit を埋め込むか」をハードコードしている。
    # つまり、仕様/論文で導かれた K0' のビット配置に従っている。
    #
    # k0d は 32bit 候補のうち、特定ビット群（ここでは bit8..22 付近）だけを持つ形。
    k0d = (
        (((j >> 13) & 1) << 22) |
        (((j >> 12) & 1) << 21) |
        (((j >> 11) & 1) << 20) |
        (((j >> 10) & 1) << 19) |
        (((j >>  9) & 1) << 18) |
        (((j >>  8) & 1) << 17) |
        (((j >>  7) & 1) << 16) |
        (((j >>  6) & 1) << 14) |
        (((j >>  5) & 1) << 13) |
        (((j >>  4) & 1) << 12) |
        (((j >>  3) & 1) << 11) |
        (((j >>  2) & 1) << 10) |
        (((j >>  1) & 1) <<  9) |
        (( j        & 1) <<  8)
    )

    # count00[a] は線形式の値 a が 0/1 のどちらになったかを数える
    # この実装は「0と1が混在したら即失格」という非常に強い判定をしている。
    count00 = [0, 0]

    for i in range(M):
        # 平文側（初期状態）
        l0 = (txt[i] >> 32)
        r0 = (txt[i] & 0xffffffff)

        # 暗号文側（4ラウンド後 + whitening）
        l4 = (ctx[i] >> 32)
        r4 = (ctx[i] & 0xffffffff)

        # 式(4.28) に対応する線形式（コメントの通り）
        #
        # a は 0/1 のパリティ値で、
        #   si([..], X) で X の指定ビット XOR を取り、
        #   それらを XOR して最終値 a を作る。
        #
        # (1) si([5,13,21], l0^r0^l4)
        # (2) si([15],      l0^l4^r4)
        # (3) si([15],      f(l0^r0^k0d))
        #
        # ここで k0d を仮定したとき、この線形式が “常に同じ値” を取る候補だけを残す。
        a = (
            si([5, 13, 21], l0 ^ r0 ^ l4) ^
            si([15],        l0 ^ l4 ^ r4) ^
            si([15],        f(l0 ^ r0 ^ k0d))
        )

        count00[a] += 1

        # 0 と 1 が両方出たなら、少なくともこの強い条件は満たさないので即捨てる
        if count00[0] != 0 and count00[1] != 0:
            break

    # M サンプルすべてで a が 0（または1）に固定される候補だけ次へ進める
    if count00[0] == M or count00[1] == M:

        # -----------------------------------------------------------------------------
        # Step 2: 残り18ビットを総当たりして K0 を復元し、4本の線形式を全部満たすものを出力
        # -----------------------------------------------------------------------------
        for l in range(1 << 18):
            # 18bit の l から 32bit の K0 候補を構成する。
            # ここも「どのビットを埋めるか」が式に依存して固定されている。
            #
            # 注意:
            # - 下のビット配置は重複があるように見えるが（例: (l>>16) が bit30 と bit22 に出る等）
            #   “K0 のあるビットが XOR で束ねられた形” を展開している可能性がある。
            # - つまり K0 の独立自由度が 32 ではなく、(K0' で縛られた上で) 18bit として扱える、
            #   という理屈に基づく実装になっている。
            k0 = (
                (((l >> 17) & 1) << 31) |
                (((l >> 16) & 1) << 30) |
                (((l >> 15) & 1) << 29) |
                (((l >> 14) & 1) << 28) |
                (((l >> 13) & 1) << 27) |
                (((l >> 12) & 1) << 26) |
                (((l >> 11) & 1) << 25) |
                (((l >> 10) & 1) << 24) |
                (((l >>  9) & 1) << 23) |
                (((l >> 16) & 1) << 22) |
                (((l >> 15) & 1) << 21) |
                (((l >> 14) & 1) << 20) |
                (((l >> 13) & 1) << 19) |
                (((l >> 12) & 1) << 18) |
                (((l >> 11) & 1) << 17) |
                (((l >> 10) & 1) << 16) |
                (((l >>  8) & 1) << 15) |
                (((l >>  6) & 1) << 14) |
                (((l >>  5) & 1) << 13) |
                (((l >>  4) & 1) << 12) |
                (((l >>  3) & 1) << 11) |
                (((l >>  2) & 1) << 10) |
                (((l >>  1) & 1) <<  9) |
                (( l        & 1) <<  8) |
                (((l >>  7) & 1) <<  7) |
                (((l >>  6) & 1) <<  6) |
                (((l >>  5) & 1) <<  5) |
                (((l >>  4) & 1) <<  4) |
                (((l >>  3) & 1) <<  3) |
                (((l >>  2) & 1) <<  2) |
                (((l >>  1) & 1) <<  1) |
                ( l        & 1)
            )

            # Step1 で得た K0' を K0 候補に反映させる（“加える”= XOR）
            k0 ^= k0d

            # 4本の線形式（式(4.24)〜(4.27)）をすべて満たす候補だけ残す
            # このコードは “0と1が混在した時点で即 break” するので高速化の役割もある。
            count01 = [0, 0]
            count02 = [0, 0]
            count03 = [0, 0]
            count04 = [0, 0]

            for m in range(M):
                l0 = (txt[m] >> 32)
                r0 = (txt[m] & 0xffffffff)
                l4 = (ctx[m] >> 32)
                r4 = (ctx[m] & 0xffffffff)

                # 式(4.24)
                a = si([23, 29], l0 ^ r0 ^ l4) ^ si([31], l0 ^ l4 ^ r4) ^ si([31], f(l0 ^ r0 ^ k0))
                count01[a] += 1
                if count01[0] != 0 and count01[1] != 0:
                    break

                # 式(4.25)
                a = si([5, 15], l0 ^ r0 ^ l4) ^ si([7], l0 ^ l4 ^ r4) ^ si([7], f(l0 ^ r0 ^ k0))
                count02[a] += 1
                if count02[0] != 0 and count02[1] != 0:
                    break

                # 式(4.26)
                a = si([15, 21], l0 ^ r0 ^ l4) ^ si([23, 31], l0 ^ l4 ^ r4) ^ si([23, 31], f(l0 ^ r0 ^ k0))
                count03[a] += 1
                if count03[0] != 0 and count03[1] != 0:
                    break

                # 式(4.27)
                a = si([13], l0 ^ r0 ^ l4) ^ si([7, 15, 23, 31], l0 ^ l4 ^ r4) ^ si([7, 15, 23, 31], f(l0 ^ r0 ^ k0))
                count04[a] += 1
                if count04[0] != 0 and count04[1] != 0:
                    break

            # 4本すべてが「全サンプルで一定（0または1）」なら K0 候補として出力
            if (
                (count01[0] == M or count01[1] == M) and
                (count02[0] == M or count02[1] == M) and
                (count03[0] == M or count03[1] == M) and
                (count04[0] == M or count04[1] == M)
            ):
                # 候補の中に真の k[0] が含まれることを確認する、という目的の出力
                print(format(k0, '08x'))
