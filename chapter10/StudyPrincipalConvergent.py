# 連分数の「収束分数（convergents）」を生成する関数 pconv(a, b)
# -----------------------------------------------------------------------------
# 目的
# - 有理数 a/b を単純連分数に展開したとき、その途中までで打ち切った近似値
#   （収束分数: convergents）
#
#     p0/q0, p1/q1, p2/q2, ..., pk/qk
#
#   を順に生成して返す。
#
# 収束分数の重要性（暗号理論でも出る）
# - 収束分数は「連分数の途中までの最良近似」を与える。
# - RSA の Wiener 攻撃などは e/N の連分数展開の収束分数から
#   秘密指数 d の候補を探索する（小さな d の場合に破れる）。
#
# -----------------------------------------------------------------------------
# 数学的背景：連分数係数と収束分数
# -----------------------------------------------------------------------------
# 有理数 a/b の単純連分数係数を
#
#   [c0, c1, ..., ck]
#
# とすると、i 番目までで打ち切った値
#
#   [c0; c1, ..., ci]
#
# が i 番目の収束分数 Pi/Qi になる。
#
# 収束分数は次の漸化式で計算できる（標準形）：
#
#   P_{-2}=0, P_{-1}=1
#   Q_{-2}=1, Q_{-1}=0
#
#   P_i = c_i * P_{i-1} + P_{i-2}
#   Q_i = c_i * Q_{i-1} + Q_{i-2}
#
# 本コードはユークリッド互除法で得られる商 q（= c_i）を逐次的に生成しながら、
# 上の漸化式（と同値な更新）で (P_i, Q_i) を更新し、収束分数列を作っている。
#
# -----------------------------------------------------------------------------
# 実装方針（このコードの読み方）
# -----------------------------------------------------------------------------
# - ユークリッド互除法：
#     a = b*q + r
#   の q（商）を連分数係数として使う。
#
# - 各ステップで q を得るたびに
#     a1, a0 = q*a1 + a0, a1
#     b1, b0 = q*b1 + b0, b1
#   と更新している。
#
# 変数の意味（直感）
# - a1/b1 : 現在の収束分数（最新の近似）
# - a0/b0 : その1つ前の収束分数
#
# これに新しい係数 q を反映すると
# - 新しい分子 = q*(現在の分子) + (前の分子)
# - 新しい分母 = q*(現在の分母) + (前の分母)
# となり、標準の収束分数漸化式と一致する。
#
# -----------------------------------------------------------------------------
# SymPy を使う理由
# -----------------------------------------------------------------------------
# - sympy.Rational(p, q) を使うと「約分された有理数」を厳密に保持できる。
# - 浮動小数点ではなく、分数として正確な近似列が得られる。
#
# 注意
# - b=0 だと % が例外になるので b!=0 が前提。
# - a,b が負のとき //, % の挙動が数学のユークリッド除算とズレることがあるので、
#   通常は a>0, b>0 を想定する。


import sympy


def pconv(a, b):
    # 入力: a, b（有理数 a/b）
    # 出力: 収束分数のリスト [p0/q0, p1/q1, ...]（sympy.Rational の列）

    # ------------------------------------------------------------
    # 1) 互除法の最初の1ステップ：a = b*q + r
    # ------------------------------------------------------------
    r = a % b   # residue（余り）
    q = a // b  # quotient（商）= 連分数係数 c0 に相当

    # ------------------------------------------------------------
    # 2) 収束分数の初期化
    # ------------------------------------------------------------
    # 収束分数の漸化式の “初期条件” を変数 (a0,b0),(a1,b1) で持つ。
    #
    # ここでの設定：
    #   a0=1, b0=0    （便宜上の1つ前）
    #   a1=q, b1=1    （最初の収束分数 = q/1）
    #
    # 標準形の (P_{-2},P_{-1},Q_{-2},Q_{-1}) と見比べると、
    # “更新がうまく回るように整えた初期値” になっている、と理解すると良い。
    a0 = 1
    b0 = 0
    a1 = q
    b1 = 1

    # 収束分数列を格納するリスト（最初は q/1）
    pconvlst = [sympy.Rational(a1, b1)]

    # ------------------------------------------------------------
    # 3) 余りが 0 になるまで互除法を回し、そのたびに収束分数を更新して追加
    # ------------------------------------------------------------
    while r != 0:
        # 次の互除法ステップへ：(a,b) <- (b,r)
        a = b
        b = r
        r = a % b
        q = a // b  # 次の連分数係数 c_i

        # 収束分数の更新（漸化式）
        # - 新分子 = q*(現分子) + 前分子
        # - 新分母 = q*(現分母) + 前分母
        #
        # 代入は “同時代入” を使って
        #   (a1,a0) <- (q*a1+a0, a1)
        #   (b1,b0) <- (q*b1+b0, b1)
        # と更新している。
        a1, a0 = q * a1 + a0, a1
        b1, b0 = q * b1 + b0, b1

        # 追加：厳密な有理数として保存
        pconvlst.append(sympy.Rational(a1, b1))

    # 最後に収束分数列（連分数の各段階の最良近似）を返す
    return pconvlst
