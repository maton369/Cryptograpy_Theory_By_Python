# 拡張ユークリッド互除法 + モジュラ逆元 + RSA（学習用）暗号化/復号デモ
# -----------------------------------------------------------------------------
# このコードは次の3つを一続きで示す：
#
# (1) 拡張ユークリッド互除法 ExtEuclid(a,b)
#     - gcd(a,b) と Bézout 係数 x,y を求め、
#         a*x + b*y = gcd(a,b)
#       を満たす (g, x, y) を返す。
#
# (2) ModInv(a, b) : a の b における逆元 a^{-1} mod b を求める
#     - gcd(a,b)=1 のときにのみ逆元が存在する。
#     - ExtEuclid により a*x + b*y = 1 が得られれば、x ≡ a^{-1} (mod b)。
#
# (3) RSA の鍵生成（p,q -> N,phi -> d）、暗号化と復号
#     - 公開鍵: (N, e)
#     - 秘密鍵: d（d ≡ e^{-1} mod φ(N)）
#     - 暗号化: C = M^e mod N
#     - 復号  : R = C^d mod N （R が元の M に戻る）
#
# -----------------------------------------------------------------------------
# 重要（セキュリティ/実務上の注意）
# -----------------------------------------------------------------------------
# - ここで示す RSA は “数学的コア” のみであり、実務で必要な安全設計（パディング）が無い。
#   実務の RSA 暗号化は OAEP、署名は PSS などのパディング方式が必須。
#   「生RSA（textbook RSA）」は決定的で、様々な攻撃に弱い。
# - p, q の値は非常に大きい（RSA-768 由来の値としてコメントされている）。
#   Python の big-int なので計算はできるが、環境によっては時間がかかる場合がある。
#
# -----------------------------------------------------------------------------
# 1) 拡張ユークリッド互除法
# -----------------------------------------------------------------------------
def ExtEuclid(a, b):
    # 再帰版の拡張互除法
    #
    # 戻り値 (g, x, y) は
    #   g = gcd(a, b)
    #   a*x + b*y = g
    # を満たす。
    #
    # ユークリッド互除法の基本式：
    #   a = b*q + r
    #   gcd(a,b) = gcd(b,r)
    #
    # 拡張版では、再帰で得た係数を戻りがけで更新し、
    # gcd を a と b の線形結合に書き直す。
    if b != 0:
        # 商 q と余り r
        q = a // b  # quotient
        r = a % b   # remainder

        # ExtEuclid(b, r) が返す (g, x1, y1) を使って係数を復元する。
        #
        # 通常の導出：
        #   g = b*x1 + r*y1
        #   r = a - b*q
        # より
        #   g = b*x1 + (a - b*q)*y1
        #     = a*y1 + b*(x1 - q*y1)
        #
        # よって (a の係数, b の係数) は (y1, x1 - q*y1)。
        #
        # ただしこの実装は受け取り順を (g, y, x) としている点に注意。
        # ここで
        #   y <- x1
        #   x <- y1
        # のように入れ替えて受け取っており、最後に (g, x, y) で返して整合させている。
        g, y, x = ExtEuclid(b, r)

        # b の係数を更新：
        #   y = x1 - q*y1
        # （この実装では y が x1、x が y1 に対応）
        y = y - q * x

        # (g, aの係数, bの係数) の順に返す
        return g, x, y

    else:
        # ベースケース：b=0 のとき gcd(a,0)=a
        #   a*1 + 0*0 = a
        return a, 1, 0


# -----------------------------------------------------------------------------
# 2) モジュラ逆元（Modular Inverse）
# -----------------------------------------------------------------------------
def ModInv(a, b):
    # modular inverse: a^{-1} mod b を求める
    #
    # 逆元が存在する条件：
    #   gcd(a, b) = 1
    #
    # ExtEuclid(a, b) で
    #   a*x + b*y = g
    # が得られ、もし g=1 なら
    #   a*x ≡ 1 (mod b)
    # なので x が a の逆元（mod b）になる。
    g, x, y = ExtEuclid(a, b)

    # 実装上の注意：
    # - x は負になることがある。
    # - 逆元は通常 0..b-1 の代表元で欲しいので、x を正に正規化する。
    #
    # ここでは while で b を足しているが、
    #   x %= b
    # と書くのがより一般的で安全（b が大きいと while は複数回回る可能性がある）。
    while x < 0:
        x = x + b

    # ここでは gcd チェックをしていないが、
    # 実務なら g!=1 の場合は逆元が存在しないので例外にするのが定石。
    return x


# -----------------------------------------------------------------------------
# 3) RSA パラメータ（p,q,N,phi,e,d）
# -----------------------------------------------------------------------------
# コメントに「RSA-768」とあるが、ここでは固定の大きな素数 p,q を与えている。
# RSA の前提は p,q が素数であること。
p = 33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489
q = 36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917

# 公開法 N = p*q（公開鍵の一部）
N = p * q

# 公開指数 e（よく使われる 65537 = 2^16 + 1）
# - 小さすぎない
# - 2進で立っているビットが少なく高速
# という理由で広く使われる定数。
e = 65537

# φ(N) = (p-1)(q-1)（オイラーのトーシェント）
# RSA の鍵関係は
#   e*d ≡ 1 (mod φ(N))
# を満たす d を求めること。
phi = (p - 1) * (q - 1)

# 秘密指数 d（秘密鍵）
# - d は e の φ における逆元
# - これが復号（および署名）の鍵となる
d = ModInv(e, phi)


# -----------------------------------------------------------------------------
# 4) メッセージ M、暗号化 C、復号 R
# -----------------------------------------------------------------------------
# メッセージ M（整数）
# - RSA では平文は通常 0 <= M < N の整数として扱う。
# - この M は 2^766 - 2^723 - 2^50 - 2^8 - 1 という形で構成されている。
#   （ビットパターンが立った大きな整数、という意図）
M = 2**766 - 2**723 - 2**50 - 2**8 - 1

# 暗号化（textbook RSA）
#   C = M^e mod N
# Python の pow(M, e, N) は繰り返し二乗法で高速に計算する（modexp）。
C = pow(M, e, N)

# 復号
#   R = C^d mod N
# d は e の逆元なので、理論上 R == M（mod N）となり、平文が復元される。
R = pow(C, d, N)

# -----------------------------------------------------------------------------
# 5) 出力（確認）
# -----------------------------------------------------------------------------
print('d=', d)
print('message=', M)
print('ciphertext=', C)
print('decrypted ciphertext=', R)

# -----------------------------------------------------------------------------
# 追加メモ（学習の次の一手）
# -----------------------------------------------------------------------------
# - 逆元計算は while ではなく x %= b の方が一般的。
# - 実務 RSA は “OAEP/PSS” のようなパディングが必須（生RSAは危険）。
# - RSA の復号が成立する理由は
#     M^{ed} ≡ M (mod N)
#   が成り立つため（ed ≡ 1 (mod φ(N)) とオイラーの定理/CRTによる）。
