# 最大公約数（GCD: Greatest Common Divisor）を求めるユークリッドの互除法
# -----------------------------------------------------------------------------
# この関数 gcd(a, b) は、2つの整数 a と b の最大公約数を返す。
#
# 最大公約数とは
# - a と b の両方を割り切る正の整数のうち、最大のもの。
# 例: gcd(12, 18) = 6
#
# アルゴリズム：ユークリッドの互除法（Euclidean Algorithm）
# - 基本事実:
#     gcd(a, b) = gcd(b, a mod b)   （b != 0 のとき）
# - 直感:
#   a を b で割った余り r = a mod b は a = qb + r を満たす。
#   a と b の公約数は r と b の公約数と一致するので、
#   問題を (a, b) -> (b, r) に縮められる。
#
# 停止性（必ず終わる理由）
# - 余り r は 0 <= r < b を満たし、r は毎回小さくなる。
# - よって有限回で r=0 になり、最後の b が gcd になる。
#
# 計算量
# - 入力の大きさを n とすると O(log n) 程度で非常に高速（厳密には連分数と関係する）。
#
# 注意点（この実装の前提）
# - b が 0 のとき a % b が例外になる。
#   実務的には gcd(a, 0)=|a| を扱えるようにすることが多い。
# - 負数が入る場合も数学的には gcd は非負で返すのが一般的なので abs を取るのが定石。
#   このコードは「正の整数 a,b」を想定している学習用とみなせる。

def gcd(a, b):
    # まず a を b で割った余り r を計算する
    # r = a mod b
    r = a % b

    # 余り r が 0 になるまで繰り返す
    # ループ不変条件（重要な性質）:
    #   ループの各段階で gcd(a, b) は元の gcd と同じ値を保つ
    # なぜなら gcd(a, b) = gcd(b, a mod b) が成り立つため。
    while r != 0:
        # (a, b) を (b, r) に更新して問題サイズを縮める
        # - b は前の余り r より大きいので、必ず小さくなっていく
        a, b = b, r

        # 新しい (a, b) で余りを再計算
        r = a % b

    # r==0 になったとき、b が最大公約数
    return b
