# RSA（textbook）復号を CRT（中国剰余定理）で高速化するデモ
# -----------------------------------------------------------------------------
# 目的
# - RSA の復号（あるいは署名）計算は
#     M = C^d mod N
#   のような大きい法 N=pq の modexp になる。
# - CRT を使うと、同じ計算を
#     mod p と mod q
#   に分解してから合成でき、計算が大幅に速くなる（CRT-RSA）。
#
# このコードが示すこと
# - φ(N)=(p-1)(q-1) を使って d を作る代わりに、
#   dp = e^{-1} mod (p-1)
#   dq = e^{-1} mod (q-1)
#   を作り、
# - C を p と q で割った余りでそれぞれ modexp を行い、
# - CRT で元の法 N に戻して “復号結果 S” を得る。
#
# 重要（実務の注意）
# - これはパディング無しの textbook RSA であり実務用途としては危険。
#   実務の暗号化は OAEP、署名は PSS が必須。
# - CRT-RSA は高速だが、故障注入攻撃（Bellcore attack）などへの対策
#   （結果検証、ブラインディング等）が実務では必要。
#
# -----------------------------------------------------------------------------
# 1) 拡張ユークリッド互除法（逆元計算の土台）
# -----------------------------------------------------------------------------
def ExtEuclid(a, b):
    # (g, x, y) を返し、a*x + b*y = g を満たす
    if b != 0:
        q = a // b  # quotient（商）
        r = a % b   # remainder（余り）
        g, y, x = ExtEuclid(b, r)
        y = y - q * x
        return g, x, y
    else:
        # gcd(a,0)=a, a*1 + 0*0 = a
        return a, 1, 0


def ModInv(a, b):
    # modular inverse: a^{-1} mod b
    # 前提：gcd(a,b)=1（互いに素）であること
    g, x, y = ExtEuclid(a, b)

    # x が負の可能性があるので正の代表元に直す
    # 実務なら x %= b の方が一般的だが、ここでは while で補正している
    while x < 0:
        x = x + b

    return x


# -----------------------------------------------------------------------------
# 2) RSA パラメータ（p, q, N, e）
# -----------------------------------------------------------------------------
# RSA-768 として与えられている大きな素数 p, q（固定）
p = 33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489
q = 36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917

# 公開法 N = p*q
N = p * q

# 公開指数 e（定番の 65537）
e = 65537

# -----------------------------------------------------------------------------
# 3) CRT 用の “復号指数” dp, dq と CRT 合成係数 t
# -----------------------------------------------------------------------------
# 通常 RSA では
#   d = e^{-1} mod φ(N)
#   φ(N)=(p-1)(q-1)
# を計算する。
#
# しかし CRT-RSA では、復号（署名）に必要なのは実は
#   mod p での指数: dp = d mod (p-1)
#   mod q での指数: dq = d mod (q-1)
# だけで足りる（フェルマーの小定理に基づく指数簡約）。
#
# さらに dp, dq は次の形で直接作れる：
#   dp = e^{-1} mod (p-1)
#   dq = e^{-1} mod (q-1)
#
# ※厳密には d ≡ e^{-1} (mod lcm(p-1,q-1)) を使う流儀もあるが、
#   ここは学習用に (p-1)(q-1) 系の標準理解で十分。
dp = ModInv(e, p - 1)
dq = ModInv(e, q - 1)

# CRT 合成に必要な係数
# t = p^{-1} mod q
# つまり p*t ≡ 1 (mod q)
# これがあると、p を掛けた項で “q 側の剰余” を合わせられる。
t = ModInv(p, q)

# -----------------------------------------------------------------------------
# 4) メッセージ M、暗号化 C
# -----------------------------------------------------------------------------
# 平文 M（整数）
# RSA の前提は 0 <= M < N。
M = 2**766 - 2**723 - 2**50 - 2**8 - 1

# 暗号化（textbook RSA）
# C = M^e mod N
C = pow(M, e, N)

# -----------------------------------------------------------------------------
# 5) CRT による復号（復元）手順
# -----------------------------------------------------------------------------
# 復号したいのは
#   S = C^d mod N
# だが、CRT-RSA では次の2本を計算する：
#
#   Sp = C^dp mod p   （p 側の復号結果）
#   Sq = C^dq mod q   （q 側の復号結果）
#
# それから CRT により mod N の解へ合成する。
#
# 理由（直感）
# - mod p では、指数は (p-1) で簡約できるので dp で十分
# - mod q でも同様に dq で十分
#
# まず C を p,q での剰余に落とす（modexp の入力を小さくする）
Mp = C % p
Mq = C % q

# それぞれ独立に modexp（N でやるより指数/法が小さいので速い）
Sp = pow(Mp, dp, p)  # ≡ C^d (mod p)
Sq = pow(Mq, dq, q)  # ≡ C^d (mod q)

# -----------------------------------------------------------------------------
# 6) CRT 合成（Garner的な形の合成）
# -----------------------------------------------------------------------------
# 求めたい S は
#   S ≡ Sp (mod p)
#   S ≡ Sq (mod q)
# を満たす値（mod N）である。
#
# 合成の定番形の一つ：
#   k = (Sq - Sp) * inv(p) mod q
#   S = Sp + k * p
#
# ここで inv(p) mod q が t。
#
# なぜこれで良いか？
# - S = Sp + k*p は自動的に mod p で Sp と一致（p を掛けた項が消える）
# - mod q では
#     S ≡ Sp + k*p ≡ Sp + (Sq-Sp)*inv(p)*p ≡ Sp + (Sq-Sp) ≡ Sq
#   となり、q 側も一致する。
#
# コードは
#   S = Sp + (Sq - Sp)*t*p
# と書いているが、厳密には (Sq-Sp)*t を mod q に落としてから p を掛けるのが定石。
# ただし最後に %N を取るので、数学的には同値な代表に収束する（計算量は増える可能性あり）。
S = Sp + (Sq - Sp) * t * p
S = S % N  # mod N の代表元に正規化

# -----------------------------------------------------------------------------
# 7) 出力（確認）
# -----------------------------------------------------------------------------
print('message=', M)
print('ciphertext=', C)
print('decrypted ciphertext=', S)

# -----------------------------------------------------------------------------
# 追加メモ（実務寄りの注意）
# -----------------------------------------------------------------------------
# - CRT-RSA は高速だが、故障注入攻撃対策として
#   復号後に S^e mod N を計算して C と一致するか検証する “結果チェック” が有効。
# - ブラインディング（C' = C * r^e mod N）なども典型的な耐性手法。
