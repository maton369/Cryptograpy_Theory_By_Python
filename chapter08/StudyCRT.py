# 拡張ユークリッド互除法 + 逆元 + 中国剰余定理（CRT: Chinese Remainder Theorem）
# -----------------------------------------------------------------------------
# このコードは、次の3段構成で CRT を実装している。
#
# (1) ExtEuclid(a, b)
#     - gcd(a,b) と Bézout 係数 (x,y) を返す（a*x + b*y = gcd(a,b)）
#
# (2) ModInv(a, b)
#     - a の b における逆元 a^{-1} (mod b) を ExtEuclid を使って求める
#
# (3) CRT(mlst, a)
#     - 連立合同式
#         x ≡ a[0] (mod m0)
#         x ≡ a[1] (mod m1)
#         ...
#         x ≡ a[k-1] (mod m_{k-1})
#       の解 x を（法 m = Π mi の下で一意な代表として）返す
#
# -----------------------------------------------------------------------------
# 中国剰余定理（CRT）の要点（暗号理論で超重要）
# -----------------------------------------------------------------------------
# CRT は「互いに素な法 m0,m1,... が与えられたとき、
# それぞれの法での剰余（a0,a1,...) を同時に満たす x が
# 法 m = m0*m1*... の下で一意に存在する」ことを保証する。
#
# 条件（重要）
# - 法 m_i 同士が互いに素（pairwise coprime）であること：
#     gcd(m_i, m_j) = 1  (i≠j)
# これが満たされると、解は mod m で一意になる。
#
# 暗号での用途例
# - RSA の高速復号（CRT-RSA）:
#   mod N = pq の計算を mod p と mod q に分けて計算して合成し高速化する。
#
# -----------------------------------------------------------------------------
# 1) 拡張ユークリッド互除法
# -----------------------------------------------------------------------------
def ExtEuclid(a, b):
    # (g, x, y) を返し、a*x + b*y = g を満たす
    # 再帰で gcd を求めつつ、戻りがけに係数を復元する。
    if b != 0:
        q = a // b  # 商
        r = a % b   # 余り

        # ExtEuclid(b, r) が返す係数を受け取る（この実装では順番が入れ替わる形）
        g, y, x = ExtEuclid(b, r)

        # 戻りがけの係数更新：
        # r = a - b*q を使って、(a,b) の係数に変換する。
        y = y - q * x

        # (g, aの係数, bの係数) の順で返す
        return g, x, y
    else:
        # b==0 のとき gcd(a,0)=a、a*1 + 0*0 = a
        return a, 1, 0


# -----------------------------------------------------------------------------
# 2) モジュラ逆元
# -----------------------------------------------------------------------------
def ModInv(a, b):
    # a^{-1} mod b を返す（gcd(a,b)=1 が前提）
    # ExtEuclid(a,b) で a*x + b*y = 1 を作れれば、x が逆元になる。
    g, x, y = ExtEuclid(a, b)

    # x が負になる場合があるので、0..b-1 の代表元に正規化する。
    # 実務では x %= b の方が一般的だが、ここでは while で補正している。
    while x < 0:
        x = x + b

    # 注意：g != 1 の場合は逆元が存在しないが、このコードはチェックしていない。
    return x


# -----------------------------------------------------------------------------
# 3) CRT（中国剰余定理）による連立合同式の合成
# -----------------------------------------------------------------------------
def CRT(mlst, a):
    # 入力
    # - mlst: 法のリスト [m0, m1, ..., mk-1]
    # - a   : 剰余のリスト [a0, a1, ..., ak-1]
    #
    # 解きたい問題
    # - x ≡ a[j] (mod mlst[j]) をすべて同時に満たす x を求める
    #
    # 出力
    # - x を 0..m-1（m=Π mi）の範囲で返す（mod m の代表元）
    #
    # アルゴリズム（構成的CRT）
    # 1) m = Π mlst[i] を作る（全体の法）
    # 2) 各 j について
    #      mj = m / mlst[j]
    #    を置くと、mj は “mlst[j] 以外の法の積” になる。
    #
    # 3) mj は mlst[j] と互いに素なので（法が互いに素なら）、
    #      inv = mj^{-1} mod mlst[j]
    #    が存在する。
    #
    # 4) 次の項
    #      term_j = a[j] * inv * mj
    #    は
    #      - mod mlst[j] では a[j] になる（mj*inv ≡ 1）
    #      - mod mlst[i!=j] では 0 になる（mj が mi を含むため）
    #
    # 5) すべての term_j を足すと、全合同式を同時に満たす x が得られる。
    #
    # 図で見ると：
    #
    #   term_j ≡ a[j] (mod m_j)
    #   term_j ≡ 0    (mod m_i) for i != j
    #
    # なので Σ term_j が “各法で必要な値だけを担当して足し合わせたもの” になる。

    # 全体の法 m = m0*m1*... を計算
    m = 1
    result = 0
    for i in range(len(mlst)):
        m *= mlst[i]

    # 各合同式を “他の法では0、当該法ではa[j]” となる項に変換して足し込む
    for j in range(len(mlst)):
        # mj = m / m_j（当該法以外の積）
        mj = m // mlst[j]

        # inv = mj^{-1} mod mlst[j]
        # （互いに素でないと逆元が存在しないのでCRT条件が必要）
        inv = ModInv(mj, mlst[j])

        # term = a[j] * inv * mj
        # mod mlst[j] では a[j]、他の法では 0 になるように設計された項
        result += a[j] * inv * mj

    # 最終的に mod m の代表元に落として返す
    return result % m


# -----------------------------------------------------------------------------
# 追加メモ（実務・学習の次の一手）
# -----------------------------------------------------------------------------
# - CRT の前提（mlst が pairwise coprime）を満たさない場合は逆元が存在しないことがある。
#   実装を堅牢にするなら gcd チェックを入れるのが定石。
# - RSA では CRT を使うと復号が高速になる：
#     M = C^d mod N を直接やる代わりに
#     Mp = C^d mod p
#     Mq = C^d mod q
#   を計算し CRT で合成する。
