import numpy as np
import matplotlib.pyplot as plt

# -----------------------------------------------------------------------------
# このコードの目的（暗号理論との関係）
# -----------------------------------------------------------------------------
# 目的は「英語の文字頻度（frequency）」を確率分布として使い、
# その分布に従う擬似的なサンプル（A〜Zの出現列）を大量に生成し、
# 実測頻度（サンプルから数えた頻度）が元の分布に近づく様子を可視化することである。
#
# これは古典暗号（単一換字式暗号など）を破るときに使う「頻度分析」の直観とつながる。
# - 英語の平文は A〜Z が一様ではなく、E, T, A, O などが多い。
# - 単一換字式暗号では文字を入れ替えるだけなので、暗号文でも頻度分布の形が残る。
# - よって暗号文の頻度分布を見れば、どの文字が E に対応しそうか推測できる。
#
# ここでは「英語の頻度分布を持つ文字列が得られる」ことを、サンプリング実験で確認する。


# -----------------------------------------------------------------------------
# サンプル数（試行回数）
# -----------------------------------------------------------------------------
N = 10000
# N は生成する文字数（サンプルサイズ）。
# - N を大きくすると、経験的頻度（countsample）が真の確率 r に近づきやすい。
#   （大数の法則：試行回数が増えるほど比率が真の確率に収束する）


# -----------------------------------------------------------------------------
# 英語の文字頻度（A〜Z の順）
# -----------------------------------------------------------------------------
ratio = np.array([
    0.08167,  # A
    0.01492,  # B
    0.02782,  # C
    0.04253,  # D
    0.12702,  # E
    0.02228,  # F
    0.02015,  # G
    0.06094,  # H
    0.06966,  # I
    0.00153,  # J
    0.00772,  # K
    0.04025,  # L
    0.02406,  # M
    0.06749,  # N
    0.07507,  # O
    0.01929,  # P
    0.00095,  # Q
    0.05987,  # R
    0.06327,  # S
    0.09056,  # T
    0.02758,  # U
    0.00978,  # V
    0.02360,  # W
    0.00150,  # X
    0.01974,  # Y
    0.00074   # Z
])
# ratio は「英語文章で各文字が現れる割合」の代表値（経験則）を入れている。
# ただし合計が厳密に 1.0 とは限らないので、次で正規化する。


# -----------------------------------------------------------------------------
# 確率分布へ正規化（合計を1にする）
# -----------------------------------------------------------------------------
r = ratio / sum(ratio)
# r は確率ベクトル（p(A), p(B), ..., p(Z)）になる。
# np.random.choice の p 引数には、合計が 1 の確率配列を渡す必要がある。
#
# 注意:
# - Python の sum(ratio) は numpy 配列を足し合わせるが、
#   numpy では通常 np.sum(ratio) を使う方が意図が明確（どちらでも動く）。


# -----------------------------------------------------------------------------
# 文字を「0〜25」の数値で表す準備
# -----------------------------------------------------------------------------
letter = np.arange(26)
# letter = [0, 1, 2, ..., 25]
# ここでは A=0, B=1, ..., Z=25 のように数値に対応させる。
# 暗号理論ではアルファベットを Z_26（mod 26）として扱うことが多く、
# その意味でも数値表現は自然である。


# -----------------------------------------------------------------------------
# 確率分布 r に従って N 個サンプリングする
# -----------------------------------------------------------------------------
sample = np.random.choice(letter, p=r, size=N)
# np.random.choice の動作:
# - 選択対象: letter（0〜25）
# - 確率: p=r（各値が選ばれる確率）
# - 個数: size=N
#
# 結果 sample は長さ N の numpy 配列。
# 例: [4, 19, 0, 4, 7, ...] のように 0〜25 が並ぶ。
#
# ここで「英語頻度に従う文字列」を人工的に生成していることになる。


# -----------------------------------------------------------------------------
# サンプルから経験的頻度を計算する（各文字の出現割合）
# -----------------------------------------------------------------------------
samplelist = sample.tolist()
# sample は numpy 配列だが、ここでは list に変換して count を使っている。

countsample = [samplelist.count(j) / N for j in range(26)]
# countsample[j] は「j が出現した回数 / N」。
# つまり経験的確率（サンプルから推定した p̂ ）である。
#
# 注意（計算量）:
# - list.count は毎回リスト全体を走査するため O(N)。
# - それを 26 回やるので O(26N) で、N が大きいと少し無駄が出る。
# - numpy を使うなら np.bincount(sample, minlength=26) / N が高速で簡潔。
#   ただしこのコードは「分かりやすさ」を優先した書き方になっている。


# -----------------------------------------------------------------------------
# 横軸ラベル（A〜Z）を作る
# -----------------------------------------------------------------------------
alphabetlist = [chr(ord("A") + i) for i in range(26)]
# ord("A") は 'A' の文字コード（ASCII/Unicode）。
# chr(...) で文字に戻す。
# つまり i=0→'A', i=1→'B', ... というラベル列を作っている。


# -----------------------------------------------------------------------------
# 棒グラフで可視化
# -----------------------------------------------------------------------------
plt.bar(alphabetlist, countsample)
# 横軸: 'A'〜'Z'
# 縦軸: サンプルから推定した出現割合 countsample

plt.show()
# グラフを表示する。
#
# 期待される見た目:
# - E が最も高く、T, A, O, I, N, S, H, R などが続く形になる。
# - N を大きくすると、棒の高さが r により近い形へ安定していく。
#
# 暗号理論的な含意:
# - この分布は単一換字式暗号で「入れ替わるが形は残る」ため、
#   暗号文の頻度分布を観察することで置換表の推定に役立つ。
