#######################
# Substitution Cipher（単一換字式暗号）
#######################
#
# 概要
# - 単一換字式暗号は「平文の各文字」を「別の文字」に 1 対 1 で置き換える暗号である。
# - 置換規則（鍵）は「アルファベットの並び替え（置換）」として表現できる。
#
# 例：
#   org = ABCDEFGHIJKLMNOPQRSTUVWXYZ
#   key = KYQBAILWEODMZJTFGVCXNPUHRS
#
# これは
#   A -> K
#   B -> Y
#   C -> Q
#   ...
# のように、org の i 番目の文字を key の i 番目の文字に写す対応を意味する。
#
# 暗号化（Enc(text, org, key)）では
#   org を「平文アルファベット」、key を「暗号文アルファベット」として使う。
#
# 復号（Enc(ctext, key, org)）では
#   org と key を入れ替えて、逆写像（key -> org）として使う。
#
# 注意（セキュリティ）
# - 単一換字式暗号は古典暗号であり、頻度分析などで破られやすい。
# - 現代の安全な暗号（AES, ChaCha20 など）とは全く別物である。
# - ここでは「暗号の概念・実装練習」目的のコードである。


import re
# re: 正規表現モジュール
# - 今回は「文字以外（記号や空白など）を除去」するために使う。


def Enc(text, org, key):
    """
    Enc: 単一換字式暗号の「置換」による変換関数（暗号化にも復号にも使える）

    Parameters
    - text: 変換したい文字列（平文でも暗号文でもよい）
    - org : 元のアルファベット（入力側の文字集合の並び）
            暗号化なら通常 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
            復号なら key（暗号化に使った置換表）をここに入れる
    - key : 置換先アルファベット（出力側の文字集合の並び）
            暗号化なら「鍵（置換表）」
            復号なら通常 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

    Returns
    - res: 置換後の文字列（暗号文 or 復号文）

    アルゴリズム（超重要）
    - 入力テキストを正規化（記号や空白を除去し、大文字化）
    - 各文字 lett について
        1) org の中で lett が何番目（index）か調べる
        2) 同じ index の位置にある key[index] に置換する
    - それを連結して結果を返す

    つまり、org と key を「同じ長さの対応表」として扱っている。
    """

    # -------------------------------------------------------------------------
    # 1) 前処理（入力の正規化）
    # -------------------------------------------------------------------------
    # r'\W+' は「英数字とアンダースコア以外」にマッチする。
    # 今回の文章には空白やピリオドが含まれるため、それらをまとめて除去する。
    #
    # 例：
    #   "Men willingly believe what they wish."
    #   → "Menwillinglybelievewhattheywish"
    #
    # 注意：
    # - \W は Unicode の扱いが絡むことがあるが、ここでは英字中心なので問題になりにくい。
    # - 今回は「英字以外を除去」したい意図だが、\W だと数字や _ は残る。
    #   もし「英字だけ残したい」なら [^A-Za-z]+ の方が意図が明確な場合がある。
    tmp = re.sub(r'\W+', '', text)

    # 大文字に統一する。
    # 置換表 org/key は大文字アルファベットのみを想定しているため、
    # 小文字が来ても処理できるようにここで揃えている。
    text = tmp.upper()

    # 結果文字列をここに構築する（1文字ずつ追加していく）
    res = ''

    # -------------------------------------------------------------------------
    # 2) 置換処理（暗号化/復号の本体）
    # -------------------------------------------------------------------------
    for lett in text:
        # org.index(lett) は org の中で lett が出現する位置（0-based）を返す。
        # 例：org="ABC...Z" なら 'A'→0, 'B'→1, ... 'Z'→25
        #
        # 注意（例外）:
        # - lett が org に存在しない場合 ValueError になる。
        #   今回は事前に大文字化していて、org は A-Z なので、
        #   入力が英字のみなら基本的に問題ない。
        index = org.index(lett)

        # 置換：入力文字 lett は org[index] に一致するので、
        # 出力として key[index] を採用する。
        #
        # 暗号化の例：
        #   org="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        #   key="KYQBAI..."
        #   lett='A' → index=0 → key[0]='K'
        #
        # 復号の例：
        #   org=key（暗号アルファベット）
        #   key=alphabet（平文アルファベット）
        #   lett='K' → index=0 → alphabet[0]='A'
        res += key[index]

    # 変換結果（暗号文または復号文）を返す
    return res


# ---------------------------------------------------------------------------
# 置換表の定義
# ---------------------------------------------------------------------------

alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
# 平文側の「標準アルファベット」。
# この並びの i 番目が置換の元（暗号化時の入力側）になる。

key = 'KYQBAILWEODMZJTFGVCXNPUHRS'
# 暗号側の「置換アルファベット（鍵）」。
# alphabet の i 番目が key の i 番目に写像される。
#
# 置換表として正しい条件：
# - 長さが 26 であること
# - A-Z が重複なく 1 回ずつ出現すること（＝置換＝全単射）
#   これが崩れると復号が一意にできなくなる。


# ---------------------------------------------------------------------------
# 平文 → 暗号文 → 復号 のデモ
# ---------------------------------------------------------------------------

ptext = 'Men willingly believe what they wish.'
# 英文の平文（句読点とスペースを含む）

ctext = Enc(ptext, alphabet, key)
# 暗号化：
# - 入力は alphabet（平文アルファベット）
# - 出力は key（暗号アルファベット）
# つまり「A-Z を key の並びに置き換える」

dtext = Enc(ctext, key, alphabet)
# 復号：
# - 入力側 org を key にする（暗号アルファベットから探す）
# - 出力側 key を alphabet にする（平文アルファベットへ戻す）
# つまり暗号化の逆写像を実現している。
#
# ここで同じ Enc 関数を使い回せるのは、
# 「org.index(lett) で位置を取り、同じ位置の別表を引く」という作りだからである。


# ---------------------------------------------------------------------------
# 結果の表示
# ---------------------------------------------------------------------------

print('plaintext:', ptext)
# 注意：
# - Enc 内で記号・空白を除去しているので、暗号化対象の実際の文字列は
#   "MENWILLINGLYBELIEVEWHATTHEYWISH"
# になっている点に注意。

print('ciphertext:', ctext)
# 暗号文は「大文字のみ・記号なし」の形式で出力される。

print('decoded ciphertext:', dtext)
# 復号結果も同様に「大文字のみ・記号なし」になる。
# つまり元の ptext と完全一致するのではなく、
# 正規化された平文（大文字＋記号除去）に戻る、という挙動である。
