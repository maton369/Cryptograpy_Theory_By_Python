#######################
# Substitution Cipher 2（単一換字式暗号：ファイル入出力版）
#######################
#
# 目的
# - 1つ前の「Substitution Cipher」の処理を、ファイルから平文を読み込んで暗号化し、
#   暗号文を別ファイルに書き出す形に拡張したコードである。
#
# このコードでやっていること（全体像）
# 1) test.txt からテキストを読み込む
# 2) そのテキストを「単一換字式暗号」で暗号化する（A-Z の置換）
# 3) 復号して元に戻るか確認する（暗号表を逆にして再置換）
# 4) 暗号文を cipher.txt に書き出す
#
# 注意（セキュリティ）
# - 単一換字式暗号は古典暗号であり、頻度分析などで容易に破られる。
# - ここでは暗号理論の学習（置換・写像・逆写像の理解）目的の実装である。


import re
# re: 正規表現モジュール
# - 記号や空白など「英数字とアンダースコア以外」を除去するために使用する。


def Enc(text, org, key):
    """
    Enc: 単一換字式暗号の置換関数（暗号化/復号を同じ関数で実現する）

    Parameters
    - text: 変換対象の文字列（平文または暗号文）
    - org : 入力側アルファベット（探索する側）
            暗号化: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
            復号  : 置換表（暗号アルファベット）key
    - key : 出力側アルファベット（置換先）
            暗号化: 置換表 key
            復号  : 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

    Returns
    - res: 置換後の文字列

    アルゴリズム（最重要）
    - text を正規化（記号除去・大文字化）
    - 各文字 lett について
        index = org.index(lett) で位置を求める
        res  += key[index]      で同じ位置の文字に置換
    - 連結した res を返す

    直観
    - org と key は「同じ長さの対応表」である。
    - org の i 番目の文字を、key の i 番目の文字に写す写像になっている。
    """

    # -------------------------------------------------------------------------
    # 1) 前処理（正規化）
    # -------------------------------------------------------------------------
    # r'\W+' は「単語構成文字（英数字と _）以外」にマッチする。
    # これを空文字に置換することで、空白や句読点などを除去する。
    #
    # 例: "Hello, world!" -> "Helloworld"
    #
    # 注意:
    # - \W だと数字や _ は残り得る（今回は英字中心なら問題になりにくい）。
    tmp = re.sub(r'\W+', '', text)

    # 置換表 org/key が大文字 A-Z を想定しているため、大文字に揃える。
    text = tmp.upper()

    # 結果を 1 文字ずつ構築する
    res = ''

    # -------------------------------------------------------------------------
    # 2) 置換処理（暗号化/復号の本体）
    # -------------------------------------------------------------------------
    for lett in text:
        # org の中で lett が何番目かを探す（0-based index）
        # 例: org="ABC...Z" なら 'A'→0, 'B'→1, ... 'Z'→25
        #
        # 注意:
        # - lett が org に含まれないと ValueError になる。
        #   このコードは英字だけを想定しているため、英字以外が混ざると落ちる可能性がある。
        index = org.index(lett)

        # 同じ位置の key[index] に置換する
        # 暗号化: alphabet -> key
        # 復号  : key -> alphabet
        res += key[index]

    return res


# ---------------------------------------------------------------------------
# 置換表（鍵）の定義
# ---------------------------------------------------------------------------

alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
# 平文側の標準アルファベット
# i 番目の文字が、暗号化時の「入力側の文字」を表す。

# key は「暗号アルファベット（置換表）」であり、alphabet と同じ長さ 26 の置換である必要がある。
# - 26 文字であること
# - A-Z が重複なく 1 回ずつ入っていること（全単射）
# これが満たされないと復号（逆写像）が壊れる。
#
#key = 'KYQBAILWEODMZJTFGVCXNPUHRS'
key = 'LODMZJTWEXNRSPUKYQBACHIFGV'
# 別の置換表（鍵）に切り替えた例。
# どの key を使うかで暗号文が変わる。
# ただし「強度」は依然として古典暗号レベルであり、現代暗号としては安全ではない。


# ---------------------------------------------------------------------------
# ファイル入出力
# ---------------------------------------------------------------------------

# 平文を読み込むファイル（入力）
# - 'r' は read モード
# - エンコーディング指定が無いので、環境依存（OS/設定依存）になり得る。
#   日本語が含まれる場合などは open(..., encoding="utf-8") などを明示すると安全。
f1 = open('test.txt', 'r')

# 暗号文を書き出すファイル（出力）
# - 'w' は write モード（既存ファイルがあれば上書き）
f2 = open('cipher.txt', 'w')

# f1.read() はファイル全体を一括で文字列として読み込む。
# - ファイルが巨大だとメモリを大量に消費するので注意（学習用途ならOK）。
s = f1.read()

# 入力テキストを大文字化
# - ただし Enc 内でも大文字化しているので、ここは「二重」に大文字化している。
#   （動作は問題ないが、厳密にはここで upper() する必要はない）
ptext = s.upper()

# ---------------------------------------------------------------------------
# 暗号化（平文 -> 暗号文）
# ---------------------------------------------------------------------------
ctext = Enc(ptext, alphabet, key)
# Enc の引数の意味:
# - org=alphabet（入力側アルファベット）
# - key=key      （出力側アルファベット＝置換表）
# よって「A-Z を key の並びに置換」して暗号文を得る。

# ---------------------------------------------------------------------------
# 復号（暗号文 -> 平文）
# ---------------------------------------------------------------------------
dtext = Enc(ctext, key, alphabet)
# 暗号化の逆操作をするため、org と key を入れ替える。
# - org=key      （暗号アルファベット側で位置を探す）
# - key=alphabet （平文アルファベット側へ戻す）
#
# これにより、暗号化で A->K のように写したものを K->A に戻せる。

# ---------------------------------------------------------------------------
# 結果表示（確認用）
# ---------------------------------------------------------------------------

print('plaintext:', ptext)
# 注意:
# - Enc は記号・空白を re.sub で除去するため、
#   実際に暗号化対象になった平文は「空白や句読点が消えた文字列」である。
# - ここで表示している ptext（s.upper()）は "元ファイルの大文字化" であり、
#   Enc 内の正規化後テキストとは一致しない場合がある（空白・記号の有無が違う）。

print('ciphertext:', ctext)
# 暗号文は大文字のみ・記号なし（Enc 内で記号除去＋大文字化しているため）。

print('decoded ciphertext:', dtext)
# 復号文も同様に「大文字のみ・記号なし」になる。
# 元ファイルの文章を完全に復元するのではなく、正規化後の文章を復元する点に注意。


# ---------------------------------------------------------------------------
# 暗号文の書き出し
# ---------------------------------------------------------------------------

f2.write(ctext)
# cipher.txt に暗号文を書き出す。
# - 改行を入れたい場合は f2.write(ctext + "\n") などにする。


# ---------------------------------------------------------------------------
# ファイルクローズ（リソース解放）
# ---------------------------------------------------------------------------

f1.close()
f2.close()
# close() を呼ぶことでファイルハンドルを閉じ、バッファをフラッシュする。
#
# 改善提案（Python流）:
# - with open(...) as f: の形式を使うと、例外が起きても自動で close されるため安全。
#   ただしここでは元コードの構造を崩さずにコメントで説明している。
