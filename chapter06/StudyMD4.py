# MD4 (Message Digest 4) の学習用実装（1ブロック程度の簡易版） + hashlib との照合
# -----------------------------------------------------------------------------
# このコードは、メッセージ "corona" に対して
#   1) hashlib（実装が提供されていれば）で MD4 を計算し、
#   2) 自前の MD4 実装で同じダイジェストを計算して
# 両者が一致することを確認する “学習用” サンプルである。
#
# 重要（暗号理論・セキュリティ観点）
# - MD4 は非常に古いハッシュ関数で、衝突攻撃が実用的に可能なレベルで破られている。
# - したがって実務の改ざん検知・署名・パスワード用途などには絶対に使わない。
# - ここでは「MD4 の内部構造（パディング、3ラウンド、論理関数、メッセージスケジュール）」
#   を理解するために扱う。
#
# MD4 の基本仕様（ざっくり）
# - 出力: 128bit（= 16バイト）
# - ブロック長: 512bit（= 64バイト）
# - 内部状態: (A,B,C,D) の 32bit×4
# - Merkle–Damgård 構造:
#   - メッセージを 512bit ブロックに分ける
#   - 各ブロックごとに圧縮関数で状態を更新し、最後に状態がダイジェスト
# - パディング:
#   - 末尾に 0x80 を 1バイト付与
#   - その後 0x00 を付けて、(長さ mod 64) が 56 になるように調整
#   - 最後に「元メッセージ長（ビット）」を 64bit little-endian で付与
#
# 注意（この実装の前提）
# - 文字列 src は ASCII/UTF-8 の範囲で 1バイト文字だけ、という前提に近い実装になっている。
#   これは ord(src[i]) を 1バイトとして扱っているため。
#   UTF-8 のマルチバイト文字を含む場合は bytes にしてから処理するのが正しい。
# - ブロック数の扱いが「短いメッセージ用」になっている（学習用としてはOK）。
#
# さらに重要（hashlib の md4 について）
# - Python の hashlib は環境（OpenSSL のビルド設定）によって 'md4' が使えない場合がある。
# - その場合は hashlib.new('md4', ...) が例外になる。
#   （このコードは例外処理をしていないので、その環境だと先頭で落ちる）


import hashlib

# -----------------------------------------------------------------------------
# 入力メッセージ
# -----------------------------------------------------------------------------
src = "corona"  # メッセージとなるデータ（文字列）

# hashlib による MD4 計算（提供されている環境なら）
# - hashlib.new('md4', data) は data(bytes) を入力として MD4 を計算する。
# - hexdigest() は 16バイトのダイジェストを 32桁16進文字列で返す。
print(hashlib.new('md4', src.encode('utf-8')).hexdigest())


# -----------------------------------------------------------------------------
# ここから自前 MD4 実装
# -----------------------------------------------------------------------------
# MD4 の第2ラウンド・第3ラウンドで使う加算定数
# - 仕様上、Round2 は 0x5a827999、Round3 は 0x6ed9eba1
# - コメントの「√2」「√3」は “由来” を想起させる書き方だが、
#   厳密には MD5 の定数（sin由来）ほど有名な導出説明が定着しているわけではなく、
#   「仕様で固定の定数」として覚えるのが実務的。
R2 = 0x5a827999  # Round2 で足す定数
R3 = 0x6ed9eba1  # Round3 で足す定数


def rol(x, n):
    # 32bit ワード x を nbit 左回転（rotate-left）
    # - MD4 は多用する：各ステップで (A + F + X[k] + const) を rol して更新する
    # - Python の int は無限長なので &0xffffffff で 32bit に丸める
    return ((((x) << (n)) | ((x) >> (32 - (n)))) & 0xffffffff)


# Round1 の論理関数 F
# F(x,y,z) = (x AND y) OR ((NOT x) AND z)
def ff(x, y, z):
    return (((x) & (y)) | (((x) ^ 0xffffffff) & (z)))


# Round2 の論理関数 G
# G(x,y,z) = (x AND y) OR (x AND z) OR (y AND z)
def gg(x, y, z):
    return (((x) & (y)) | ((x) & (z)) | ((y) & (z)))


# Round3 の論理関数 H
# H(x,y,z) = x XOR y XOR z
def hh(x, y, z):
    return ((x) ^ (y) ^ (z))


def conv(x):
    # Big endian <-> Little endian 変換（32bit）
    #
    # MD4 の出力は “状態(A,B,C,D) を little-endian のバイト列として並べたもの” である。
    # しかし Python で 32bit 整数を format(...,'08x') すると “数値としての16進表記” になるため、
    # そのままだと endianness が人間の期待とズレることがある。
    #
    # conv は 32bit のバイト順を逆転する（ABCD <-> DCBA）操作になっている。
    #
    # 例:
    #   x = 0x11223344
    #   conv(x) = 0x44332211
    return (x >> 24) ^ ((x >> 8) & 0x0000ff00) ^ ((x << 8) & 0x00ff0000) ^ ((x & 0xff) << 24)


# -----------------------------------------------------------------------------
# MD4 のステップで使う “回転量配列 s” と “メッセージワード順 t”
# -----------------------------------------------------------------------------
# MD4 は 1ブロックあたり 48 ステップ。
# - Round1: 16ステップ
# - Round2: 16ステップ
# - Round3: 16ステップ
#
# 各ステップ j で「何ビット回転するか」が s[j]。
# 各ステップ j で「メッセージワード X[k] のどれを使うか」が t[j]。

s = [
     3,  7, 11, 19,  3,  7, 11, 19,  3,  7, 11, 19,  3,  7, 11, 19,  # Round1
     3,  5,  9, 13,  3,  5,  9, 13,  3,  5,  9, 13,  3,  5,  9, 13,  # Round2
     3,  9, 11, 15,  3,  9, 11, 15,  3,  9, 11, 15,  3,  9, 11, 15   # Round3
]

t = [
     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,  # Round1: 0..15
     0,  4,  8, 12,  1,  5,  9, 13,  2,  6, 10, 14,  3,  7, 11, 15,  # Round2: (0,4,8,12,1,5,...)
     0,  8,  4, 12,  2, 10,  6, 14,  1,  9,  5, 13,  3, 11,  7, 15   # Round3: (0,8,4,12,2,10,...)
]


# -----------------------------------------------------------------------------
# 2) パディングと 512bit ブロックへの整形
# -----------------------------------------------------------------------------
# ここが MD4（およびMD5/SHA-1 等の Merkle–Damgård 系）で大事な部分：
# - “1” ビット（= 0x80）を付ける
# - “0” ビットを付けて 56byte 境界に合わせる
# - 最後に元メッセージ長（bit長）を 64bit little-endian で付ける
#
# この実装では、メッセージを 32bit ワード列 x[] に落とし込むために
# まず data という巨大整数に「小端（little-endian）でバイトを詰める」方針を取っている。

data = 0

# src の各文字を 1バイトとして data に詰める
# - (8*i) ずつ左に寄せて OR するので、i=0 が最下位バイトになる（little-endian 詰め）
for i in range(len(src)):
    data |= ord(src[i]) << (8 * i)

# 末尾に 0x80 を付与（= 10000000b を1バイト付ける）
# - 本来は「1ビット付与」だが、バイト実装では 0x80 を付けるのが定石
data |= 0x80 << (len(src) * 8)

# x は 32bit ワード配列（メッセージブロックを 16ワード単位で処理する）
# サイズ計算：
# - int(((len(src)+8))/64) は「長さ + 8byte（長さフィールドの分）を足したときの 64byte ブロック数」を見積もる意図
# - *16 は 1ブロック=16ワード
# - +16 は “最後にもう1ブロック足りるケース” を雑に吸収するためのバッファ
#
# 学習用としてはOKだが、一般化するなら「正しいパディングに基づくブロック数計算」を明示する方が安全。
x = [0 for i in range(int(((len(src) + 8)) / 64) * 16 + 16)]

# data から 32bit ずつ取り出して x[0], x[1], ... に入れる
# - MD4 のメッセージワードは little-endian 32bit なので、この詰め方と整合している
for i in range(int(len(src) / 4) + 1):
    x[i] = data & 0xffffffff
    data = (data >> 32)

# 末尾に「元メッセージ長（bit長）」を格納する。
# MD4 では長さは 64bit little-endian で最後の 2ワード（X[14],X[15]）に入る。
# この実装は “短文” 想定で X[14] 相当だけを書いている（上位32bitは0の前提）。
x[int(((len(src) + 8)) / 64) * 16 + 14] = (len(src) * 8)


# -----------------------------------------------------------------------------
# 3) 圧縮関数（1ブロックあたり48ステップ、Round1〜3）
# -----------------------------------------------------------------------------
# 初期値（IV）
# - A,B,C,D の初期値は仕様で固定
# - これらは little-endian 前提の定数としてよく知られている
a, b, c, d = a0, b0, c0, d0 = 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476

# ブロックループ
# int(((len(src)+8))/64)+1 が “ブロック数” の意図（学習用の簡易計算）
for i in range(int(((len(src) + 8)) / 64) + 1):
    # Round1: 16ステップ（定数なし）
    # 更新式（仕様表記の一例）:
    #   A = rol(A + F(B,C,D) + X[k], s)
    #   (A,B,C,D) が入れ替わる実装表現になっている（d, new_b, b, c）
    for j in range(16):
        a, b, c, d = (
            d,
            rol(((a + ff(b, c, d) + x[16 * i + t[j]]) & 0xffffffff), s[j]),
            b,
            c
        )

    # Round2: 16ステップ（+R2）
    for j in range(16, 32):
        a, b, c, d = (
            d,
            rol(((a + gg(b, c, d) + x[16 * i + t[j]] + R2) & 0xffffffff), s[j]),
            b,
            c
        )

    # Round3: 16ステップ（+R3）
    for j in range(32, 48):
        a, b, c, d = (
            d,
            rol(((a + hh(b, c, d) + x[16 * i + t[j]] + R3) & 0xffffffff), s[j]),
            b,
            c
        )

    # ブロック処理後：初期状態（a0,b0,c0,d0）に加算してチェーンする
    # Merkle–Damgård の “feed-forward” に相当
    a, b, c, d = a0, b0, c0, d0 = (
        (a + a0) & 0xffffffff,
        (b + b0) & 0xffffffff,
        (c + c0) & 0xffffffff,
        (d + d0) & 0xffffffff
    )

# -----------------------------------------------------------------------------
# 4) ダイジェスト出力
# -----------------------------------------------------------------------------
# MD4 の最終出力は A,B,C,D を little-endian のバイト列として連結したもの。
# ここでは見やすく 32bit ごとに 8桁 hex で表示する。
# conv() で byte order を反転させて「一般的な表示形式」に合わせている。
print(
    format(conv(a & 0xffffffff), '08x'),
    format(conv(b & 0xffffffff), '08x'),
    format(conv(c & 0xffffffff), '08x'),
    format(conv(d & 0xffffffff), '08x')
)

# 上記コードの実行によるメッセージダイジェスト（hashlib の md4 と一致するはず）
#
# -----------------------------------------------------------------------------
# 追加メモ（学習の次の一手）
# -----------------------------------------------------------------------------
# - この実装は “短いメッセージ” を主に想定しているので、
#   任意長メッセージに対応するには
#   (1) bytes 入力を扱う
#   (2) 正しいパディング（56byte境界と64bit長さ付与）を厳密に実装する
#   (3) 512bitブロックを順に処理する
#   を明示的に書くと理解が深まる。
#
# - MD4 がなぜ危険かを体験するなら、
#   「衝突生成（collision）」の実例や、MD4 を元にした古いプロトコル（NTLM など）での問題を調べると良い。
