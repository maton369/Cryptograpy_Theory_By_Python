# Collision search of hash function MD4（MD4 の衝突ペア導出テスト）
# -----------------------------------------------------------------------------
# 目的
# - MD4 は衝突（異なるメッセージが同じハッシュ値になる）を作れることで有名である。
# - このコードは「衝突ペア (X, Y)」となる 1ブロック（512bit）入力を、
#   既知の差分パターンと中間状態（Q系列）の条件を満たすように構成し、
#   最後に md4one(x) と md4one(y) が一致すること（=衝突）を確認する実験コードである。
#
# 実装の大枠（何をしているか）
# 1) MD4 の 1ブロック圧縮関数 md4one(aa,bb,cc,dd,z) を実装（入力は 16ワード）
# 2) MD4 の中間状態を Q[-4]..Q[??] の形で管理し、衝突構築に必要な差分条件を満たす Q と Q' を作る
# 3) Q, Q' から逆算してメッセージワード X[i] を復元する（式(6.xx)）
# 4) 2つ目のメッセージ Y は X の一部ワードを +1 する等の「差分」を入れたものとして作る
# 5) 実際に MD4 を計算し、h1 == h2 なら衝突が得られたので出力して終了
#
# 注意（暗号理論/セキュリティ）
# - MD4 は衝突耐性が破られているため、セキュリティ用途に用いてはいけない。
# - これは「衝突構成手順」を理解するための学習・検証コードである。
# - ここでいう “衝突探索” は「ランダムに総当たり」ではなく、
#   文献で知られている差分パス（中間状態条件）を満たすようにメッセージを“構成”している。
#
# 変数名の読み方（重要）
# - x[0..15] : 1つ目メッセージブロック X（16ワード=512bit）
# - y[0..15] : 2つ目メッセージブロック Y（X に特定差分を入れたもの）
# - q[i]     : MD4 の中間状態 Q_i（あるステップ後の B 相当など、文献定義に従う系列）
# - r[i]     : 差分を入れた側の中間状態 Q'_i（q と対応する “ペア側”）
# - pl/mi    : mod 2^32 の加算・減算
#
# このコードの「衝突が成立する」ための基本差分
# - よくある MD4 衝突構成では、メッセージワードの差分として
#   ΔX[12] = +1 のような小さな差分を入れ、内部差分が打ち消し合うように条件を作る。
# - 本コードでも y[12] = x[12] + 1 を入れている。


import random

# -----------------------------------------------------------------------------
# MD4 のラウンド定数
# -----------------------------------------------------------------------------
R2 = 0x5a827999  # Round2 の加算定数
R3 = 0x6ed9eba1  # Round3 の加算定数


def rol(x, n):
    # 32bit 左回転（rotate left）
    return (((x << n) | (x >> (32 - n))) & 0xffffffff)


# Round1 の論理関数 F
def ff(x, y, z):
    return ((x & y) | ((x ^ 0xffffffff) & z))


# Round2 の論理関数 G
def gg(x, y, z):
    return ((x & y) | (x & z) | (y & z))


# Round3 の論理関数 H
def hh(x, y, z):
    return (x ^ y ^ z)


def conv(x):
    # 32bit のバイト順反転（big<->little の見かけを合わせる表示用）
    # 例: 0x11223344 -> 0x44332211
    return (x >> 24) ^ ((x >> 8) & 0x0000ff00) ^ ((x << 8) & 0x00ff0000) ^ ((x & 0xff) << 24)


def pl(a, b):
    # (a + b) mod 2^32
    return ((a + b) & 0xffffffff)


def mi(a, b):
    # (a - b) mod 2^32
    return ((a + ((1 << 32) - b)) & 0xffffffff)


def md4one(aa, bb, cc, dd, z):
    # MD4 を 1ブロック（16ワード）だけ処理する圧縮関数
    #
    # 入力
    # - aa,bb,cc,dd : 初期状態 (A,B,C,D)
    # - z          : 16ワード（512bitブロック）
    #
    # 出力
    # - ブロック処理後の状態を 128bit 整数 (A||B||C||D) として返す
    #
    # MD4 は 48ステップ（Round1/2/3 各16ステップ）で状態を更新する。
    # この関数は「一般のMD4（複数ブロック＋パディング）」ではなく、
    # “すでに 16ワードに整形された 1ブロック” を処理するだけの部品である。

    # 回転量（48ステップ分）
    s = [
        3, 7, 11, 19,  3, 7, 11, 19,  3, 7, 11, 19,  3, 7, 11, 19,   # Round1
        3, 5,  9, 13,   3, 5,  9, 13,   3, 5,  9, 13,   3, 5,  9, 13, # Round2
        3, 9, 11, 15,   3, 9, 11, 15,   3, 9, 11, 15,   3, 9, 11, 15  # Round3
    ]

    # メッセージワード参照順（48ステップ分）
    t = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,          # Round1
        0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15,          # Round2
        0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15           # Round3
    ]

    # 作業レジスタ
    a, b, c, d = aa, bb, cc, dd

    # Round1: a = rol(a + F(b,c,d) + X[k], s)
    for j in range(16):
        a, b, c, d = d, rol(pl(pl(a, ff(b, c, d)), z[t[j]]), s[j]), b, c

    # Round2: +R2 を足す
    for j in range(16, 32):
        a, b, c, d = d, rol(pl(pl(pl(a, gg(b, c, d)), z[t[j]]), R2), s[j]), b, c

    # Round3: +R3 を足す
    for j in range(32, 48):
        a, b, c, d = d, rol(pl(pl(pl(a, hh(b, c, d)), z[t[j]]), R3), s[j]), b, c

    # feed-forward（初期状態を足し戻す）
    a, b, c, d = pl(a, aa), pl(b, bb), pl(c, cc), pl(d, dd)

    return ((a << 96) | (b << 64) | (c << 32) | d)


# -----------------------------------------------------------------------------
# 衝突構築で使う中間状態系列 Q と Q'
# -----------------------------------------------------------------------------
# ここでは q と r を「添字 -4 .. 47」くらいで参照したいが、
# Python のリストは 0 から始まるので、
#   q[-4], q[-3], q[-2], q[-1] のような “負の添字” をそのまま使っている。
#
# 注意:
# - Python の負の添字は「末尾から数える」意味になるので通常は危険だが、
#   このコードは q を十分長く確保し、あえて q[-4] などを “IV用スロット” として使うスタイル。
# - ただし可読性は落ちるので、学習では「offsetを持つ配列」や dict の方が理解しやすい。
q = [0 for i in range(-4, 48)]
r = [0 for i in range(-4, 48)]

# メッセージワード X, Y（衝突ペア）
x = [0 for i in range(16)]
y = [0 for i in range(16)]

# MD4 の IV を Q[-4..-1] に入れる（文献での Q_{-4}..Q_{-1} 的な置き方）
q[-4], q[-1], q[-2], q[-3] = 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476

# -----------------------------------------------------------------------------
# 既知の差分パスに基づく “固定条件” をセット
# -----------------------------------------------------------------------------
# ここは文献の式(6.4)〜(6.10) 等で与えられる「中間状態差分条件」の一部を固定している。
#
# 例:
# - Q_11 = Q'_11 = 0
# - Q_12 = -1 (0xffffffff), Q'_12 = 0
# - Q_14 と Q'_14 を特定値に固定
#
# これらは「衝突が成立する差分経路」に沿うための拘束である。
q[11] = r[11] = 0
q[10] = r[10] = 0
q[12] = 0xffffffff
r[12] = 0
q[13] = 0xfffdfffe
r[13] = q[13]
q[14] = 0xedffcfff
r[14] = 0xfdffdfff


# -----------------------------------------------------------------------------
# 衝突構築の探索ループ
# -----------------------------------------------------------------------------
# ここからは “条件を満たす Q 系列のランダム探索” と
# “その Q から逆算して X ワードを復元する” パートになる。
#
# while True が入れ子になっているのは、
# - 条件(1)(2)(3)(4) を順に満たす乱数を引けるまで回す
# - 次に X/Y ワードを完成させ、さらに後段の差分条件（表6.1）を満たすまで回す
# という流れを “成功するまで繰り返す” ためである。


while True:
    # -----------------------------
    # Phase 1: Q15〜Q19 あたりの差分条件を満たす Q, Q' を探す
    # -----------------------------
    while True:
        # 1) Q15 をランダムに選び、Q'15 を差分条件に従って作る
        #    r[15] = q[15] - 2^25 + 1
        #    ここで 0x00001001 は (2^12 + 1) に見えるが、式の展開により現れる固定差分と解釈する。
        while True:
            q[15] = random.randint(0, 0xffffffff)
            r[15] = mi(q[15], 0x00001001)

            # 式(6.5),(6.6) に対応する条件チェック
            # - Round1/2 の関数差分が、回転後の差分と整合するかを見ている。
            # - ここを満たすと、差分が “狙った形で伝播する” 可能性が高くなる。
            if (
                mi(ff(r[14], r[13], r[12]), ff(q[14], q[13], q[12])) == mi(rol(r[15], 13), rol(q[15], 13))
                and mi(gg(r[15], r[14], r[13]), gg(q[15], q[14], q[13])) == 0xffffffff
            ):
                break

        # 2) Q16 をランダムに選び、Q'16=Q16 とする（式(6.4)）
        #    さらに G の値が一致する制約（式(6.7)）を満たすまで回す。
        while True:
            q[16] = random.randint(0, 0xffffffff)
            r[16] = q[16]
            if gg(q[16], r[15], r[14]) == gg(q[16], q[15], q[14]):
                break

        # 3) Q17,Q18,Q19 をランダムに選び、Q'17,Q'18,Q'19 を差分条件に従って作る
        #    r[19] = q[19] - 2^25
        #    r[18] = q[18] + 2^5
        #    r[17] = q[17]
        #
        #    そして式(6.8),(6.9) に対応する差分整合条件をチェック。
        while True:
            q[17] = random.randint(0, 0xffffffff)
            q[18] = random.randint(0, 0xffffffff)
            q[19] = random.randint(0, 0xffffffff)

            r[19] = mi(q[19], (1 << 25))
            r[18] = pl(q[18], (1 << 5))
            r[17] = q[17]

            if (
                mi(gg(q[17], q[16], r[15]), gg(q[17], q[16], q[15]))
                == pl(mi(q[14], r[14]), mi(rol(r[18], 23), rol(q[18], 23)))
                and gg(r[18], q[17], q[16]) == gg(q[18], q[17], q[16])
            ):
                break

        # 4) さらに式(6.10) の条件を満たすかチェック（満たせば Phase1 終了）
        if gg(r[19], r[18], q[17]) == gg(q[19], q[18], q[17]):
            break

    # -----------------------------
    # Phase 2: X[0..15] と Y[0..15] を構成し、後段の差分条件（表6.1）を満たすか検証
    # -----------------------------
    while True:
        # ここは「Q の値から X の値を逆算する」パート。
        # 典型的には
        #   Q_{i} = rol(Q_{i-4} + F/G/H(...) + X[k] + const, s)
        # の形を
        #   X[k] = ror(Q_i, s) - Q_{i-4} - F/G/H(...) - const
        # のように解いてメッセージワードを復元する。
        #
        # 下の式(6.11)〜(6.24) はその “逆算式” を並べたものになっている。

        # X13 をランダムに与え、そこから X14,X15 や Q9,Q8 等を逆算で合わせる
        x[13] = random.randint(0, 0xffffffff)

        # 式(6.11)〜(6.16): Q と既知値から X14,X15,X0,X4,X8,X12 を復元
        x[14] = mi(mi(rol(q[14], 21), q[10]), ff(q[13], q[12], q[11]))
        x[15] = mi(mi(rol(q[15], 13), q[11]), ff(q[14], q[13], q[12]))
        x[0]  = mi(mi(mi(rol(q[16], 29), q[12]), gg(q[15], q[14], q[13])), R2)
        x[4]  = mi(mi(mi(rol(q[17], 27), q[13]), gg(q[16], q[15], q[14])), R2)
        x[8]  = mi(mi(mi(rol(q[18], 23), q[14]), gg(q[17], q[16], q[15])), R2)
        x[12] = mi(mi(mi(rol(q[19], 19), q[15]), gg(q[18], q[17], q[16])), R2)

        # 式(6.17),(6.18): Q13,Q12 から Q9,Q8 を逆算（ここで x[13], x[12] が入る）
        q[9] = mi(mi(rol(q[13], 25), ff(q[12], q[11], q[10])), x[13])
        q[8] = mi(mi(rol(q[12], 29), ff(q[11], q[10], q[9])), x[12])

        # いくつかのワードはランダムに埋める（自由度）
        x[1] = random.randint(0, 0xffffffff)
        x[2] = random.randint(0, 0xffffffff)
        x[3] = random.randint(0, 0xffffffff)
        x[5] = random.randint(0, 0xffffffff)

        # q[7] を固定（差分パスの拘束）
        q[7] = 0xffffffff

        # Round1 の前半を実際に計算して Q0..Q5 を整合させる
        # （ここは “逆算” ではなく “順計算” でつないでいる）
        q[0] = rol(((q[-4] + ff(q[-1], q[-2], q[-3]) + x[0]) & 0xffffffff), 3)
        q[1] = rol(((q[-3] + ff(q[0],  q[-1], q[-2]) + x[1]) & 0xffffffff), 7)
        q[2] = rol(((q[-2] + ff(q[1],  q[0],  q[-1]) + x[2]) & 0xffffffff), 11)
        q[3] = rol(((q[-1] + ff(q[2],  q[1],  q[0])  + x[3]) & 0xffffffff), 19)
        q[4] = rol(((q[0]  + ff(q[3],  q[2],  q[1])  + x[4]) & 0xffffffff), 3)
        q[5] = rol(((q[1]  + ff(q[4],  q[3],  q[2])  + x[5]) & 0xffffffff), 7)

        # 式(6.19)〜(6.24): 残りワードを埋めるために必要な Q6 と X6..X11 を逆算
        q[6]  = mi(mi(rol(q[8], 29), q[4]), x[8])
        x[6]  = mi(mi(rol(q[6], 21), q[2]), ff(q[5], q[4], q[3]))
        x[7]  = mi(mi(0xffffffff, q[3]),    ff(q[6], q[5], q[4]))
        x[9]  = mi(mi(rol(q[9], 25), q[5]), ff(q[8], q[7], q[6]))
        x[10] = mi(mi(rol(q[10],21), q[6]), ff(q[9], q[8], q[7]))
        x[11] = mi(mi(rol(q[11],13), q[7]), ff(q[10],q[9], q[8]))

        # Q'[0..9] は Q と同一、という差分パス条件を適用
        for i in range(10):
            r[i] = q[i]

        # Y は X のコピーとして作り、衝突差分として Y[12]=X[12]+1 を入れる
        for i in range(16):
            y[i] = x[i]
        y[12] = pl(y[12], 1)

        # -----------------------------
        # Round2/3 の中間状態 Q20..Q35 を順計算し、
        # その差分が “表6.1” の指定差分を満たすかチェックする
        # -----------------------------

        # Q[20]〜Q[35]
        q[20] = rol(((q[16] + gg(q[19], q[18], q[17]) + x[1]  + R2) & 0xffffffff), 3)
        q[21] = rol(((q[17] + gg(q[20], q[19], q[18]) + x[5]  + R2) & 0xffffffff), 5)
        q[22] = rol(((q[18] + gg(q[21], q[20], q[19]) + x[9]  + R2) & 0xffffffff), 9)
        q[23] = rol(((q[19] + gg(q[22], q[21], q[20]) + x[13] + R2) & 0xffffffff),13)
        q[24] = rol(((q[20] + gg(q[23], q[22], q[21]) + x[2]  + R2) & 0xffffffff), 3)
        q[25] = rol(((q[21] + gg(q[24], q[23], q[22]) + x[6]  + R2) & 0xffffffff), 5)
        q[26] = rol(((q[22] + gg(q[25], q[24], q[23]) + x[10] + R2) & 0xffffffff), 9)
        q[27] = rol(((q[23] + gg(q[26], q[25], q[24]) + x[14] + R2) & 0xffffffff),13)
        q[28] = rol(((q[24] + gg(q[27], q[26], q[25]) + x[3]  + R2) & 0xffffffff), 3)
        q[29] = rol(((q[25] + gg(q[28], q[27], q[26]) + x[7]  + R2) & 0xffffffff), 5)
        q[30] = rol(((q[26] + gg(q[29], q[28], q[27]) + x[11] + R2) & 0xffffffff), 9)
        q[31] = rol(((q[27] + gg(q[30], q[29], q[28]) + x[15] + R2) & 0xffffffff),13)
        q[32] = rol(((q[28] + hh(q[31], q[30], q[29]) + x[0]  + R3) & 0xffffffff), 3)
        q[33] = rol(((q[29] + hh(q[32], q[31], q[30]) + x[8]  + R3) & 0xffffffff), 9)
        q[34] = rol(((q[30] + hh(q[33], q[32], q[31]) + x[4]  + R3) & 0xffffffff),11)
        q[35] = rol(((q[31] + hh(q[34], q[33], q[32]) + x[12] + R3) & 0xffffffff),15)

        # Q'[20]〜Q'[35]（y を使って計算）
        r[20] = rol(((r[16] + gg(r[19], r[18], r[17]) + y[1]  + R2) & 0xffffffff), 3)
        r[21] = rol(((r[17] + gg(r[20], r[19], r[18]) + y[5]  + R2) & 0xffffffff), 5)
        r[22] = rol(((r[18] + gg(r[21], r[20], r[19]) + y[9]  + R2) & 0xffffffff), 9)
        r[23] = rol(((r[19] + gg(r[22], r[21], r[20]) + y[13] + R2) & 0xffffffff),13)
        r[24] = rol(((r[20] + gg(r[23], r[22], r[21]) + y[2]  + R2) & 0xffffffff), 3)
        r[25] = rol(((r[21] + gg(r[24], r[23], r[22]) + y[6]  + R2) & 0xffffffff), 5)
        r[26] = rol(((r[22] + gg(r[25], r[24], r[23]) + y[10] + R2) & 0xffffffff), 9)
        r[27] = rol(((r[23] + gg(r[26], r[25], r[24]) + y[14] + R2) & 0xffffffff),13)
        r[28] = rol(((r[24] + gg(r[27], r[26], r[25]) + y[3]  + R2) & 0xffffffff), 3)
        r[29] = rol(((r[25] + gg(r[28], r[27], r[26]) + y[7]  + R2) & 0xffffffff), 5)
        r[30] = rol(((r[26] + gg(r[29], r[28], r[27]) + y[11] + R2) & 0xffffffff), 9)
        r[31] = rol(((r[27] + gg(r[30], r[29], r[28]) + y[15] + R2) & 0xffffffff),13)
        r[32] = rol(((r[28] + hh(r[31], r[30], r[29]) + y[0]  + R3) & 0xffffffff), 3)
        r[33] = rol(((r[29] + hh(r[32], r[31], r[30]) + y[8]  + R3) & 0xffffffff), 9)
        r[34] = rol(((r[30] + hh(r[33], r[32], r[31]) + y[4]  + R3) & 0xffffffff),11)
        r[35] = rol(((r[31] + hh(r[34], r[33], r[32]) + y[12] + R3) & 0xffffffff),15)

        # 差分条件チェック（表6.1 などに対応）
        # - mi(q[i], r[i]) が指定の差分値になることを要求している。
        # - これを満たすと、最終的に feed-forward 後の出力が一致しやすい。
        if (
            mi(q[20], r[20]) == 0 and mi(q[21], r[21]) == 0
            and mi(q[22], r[22]) == 0xffffc000   # -(1<<14)
            and mi(q[23], r[23]) == 0x00000040   #  (1<<6)
            and mi(q[24], r[24]) == 0 and mi(q[25], r[25]) == 0
            and mi(q[26], r[26]) == 0xff800000   #  -(1<<23)
            and mi(q[27], r[27]) == 0x00080000   #   (1<<19)
            and mi(q[28], r[28]) == 0 and mi(q[29], r[29]) == 0
            and mi(q[30], r[30]) == 0xffffffff   # -1
            and mi(q[31], r[31]) == 1            #  1
            and mi(q[32], r[32]) == 0 and mi(q[33], r[33]) == 0
            and mi(q[34], r[34]) == 0 and mi(q[35], r[35]) == 0
        ):
            break

    # -----------------------------
    # Phase 3: 実際に MD4 を計算して “本当に衝突しているか” を確認
    # -----------------------------
    # IV を与えて 1ブロック圧縮を計算
    h1 = md4one(0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, x)
    h2 = md4one(0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, y)

    # 衝突していれば出力して終了、そうでなければまた探索を続ける
    if h1 == h2:
        print(format(h1, '032x'), format(h2, '032x'))
        for i in range(16):
            print("x[", format(i, '2d'), "]=", "0x", format(x[i], '08x'))
        break
