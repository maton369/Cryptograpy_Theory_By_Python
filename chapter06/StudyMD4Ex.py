# Hash function MD4 テスト（"CONTRACT"）: 2ブロック入力を想定した md4one 実装 + 1ワード差分の比較
# -----------------------------------------------------------------------------
# 目的
# - MD4 の圧縮関数（512bitブロック単位の処理）を 2ブロック分だけ実行する関数 md4one(z) を用意し、
# - その入力ブロック列 z（32ワード = 2ブロック分）を少しだけ変えた y と比較して、
#   出力ハッシュがどう変わるか（拡散）を観察する。
#
# 具体的にこのコードがしていること
# 1) 32bitワード×32個（= 1024bit）からなる入力列 x を作る（2ブロック分）
# 2) 文字列 txt の一部を x[5]〜x[15] に詰める（バイト→little-endian 32bitワード）
# 3) y を x のコピーとして作り、y[12] を +1 して 1ワード差分を入れる
# 4) パディングらしき値（0x80 と長さ 512）を所定位置に入れる
# 5) md4one(x) と md4one(y) を計算し、結果を表示する
#
# 注意（暗号理論・セキュリティ）
# - MD4 は古いハッシュで、衝突攻撃が実用的に可能なレベルで破られている。
# - このコードは学習・実験目的の参照実装であり、実務用途には使わない。
#
# 注意（このコードの “テストの性質”）
# - md4one は「一般の MD4 実装」ではなく、
#   入力 z を “すでに 32bitワード列（2ブロック分）として与える” 前提の関数である。
#   つまり bytes からパディングしてブロック化する一般実装ではない。
# - x[16]=0x80, x[30]=512 などの設定は “パディングの一部” を手で埋めている意図に見えるが、
#   MD4 の厳密なパディング（56byte境界 + 64bit長さ little-endian）を一般化しているわけではない。
#   このテストは「特定の入力構造を作って圧縮関数の挙動を見る」ことに主眼がある。


# -----------------------------------------------------------------------------
# MD4 のラウンド定数
# -----------------------------------------------------------------------------
R2 = 0x5a827999  # Round2 で足す定数（仕様固定）
R3 = 0x6ed9eba1  # Round3 で足す定数（仕様固定）


def rol(x, n):
    # 32bit 左回転（rotate-left）
    # - MD4 の各ステップは add → rotate → add の形をとるため回転が多用される
    return ((((x) << (n)) | ((x) >> (32 - (n)))) & 0xffffffff)


# Round1 の論理関数 F
# F(x,y,z) = (x & y) | (~x & z)
def ff(x, y, z):
    return (((x) & (y)) | (((x) ^ 0xffffffff) & (z)))


# Round2 の論理関数 G
# G(x,y,z) = (x & y) | (x & z) | (y & z)
def gg(x, y, z):
    return (((x) & (y)) | ((x) & (z)) | ((y) & (z)))


# Round3 の論理関数 H
# H(x,y,z) = x ^ y ^ z
def hh(x, y, z):
    return ((x) ^ (y) ^ (z))


def conv(x):
    # 32bit のバイト順反転（Big endian <-> Little endian）
    # - MD4 の出力は little-endian のバイト列として A,B,C,D を連結する。
    # - しかし数値として16進表示するときは “バイト順” が直感とズレることがある。
    # - conv は 0x11223344 -> 0x44332211 のようにバイトを反転して表示の整合を取る。
    return (x >> 24) ^ ((x >> 8) & 0x0000ff00) ^ ((x << 8) & 0x00ff0000) ^ ((x & 0xff) << 24)


def md4one(z):
    # md4one: 2ブロック分（32ワード）の入力 z に対し、MD4 の圧縮関数を2回適用してダイジェストを返す
    #
    # 入力:
    # - z: 長さ 32 の配列（32bitワード）
    #   - z[0..15]  : 1ブロック目の 16ワード（512bit）
    #   - z[16..31] : 2ブロック目の 16ワード（512bit）
    #
    # 出力:
    # - 128bit のダイジェストを 1つの整数として返す
    #   (A||B||C||D をそれぞれ 32bit にして連結した 128bit 整数)
    #
    # 処理の流れ（MD4 仕様）
    # - 初期値 (A,B,C,D) をセット
    # - ブロックごとに
    #   Round1(16ステップ) → Round2(16ステップ) → Round3(16ステップ)
    #   の合計 48 ステップを適用
    # - ブロック処理後に feed-forward（元のA0..D0を足す）でチェーンする
    #
    # 実装上の注意
    # - この関数は “パディング” はやらない。z にはすでにパディング済み相当のワード列を渡す前提。
    # - for i in range(2) でブロック数=2 を固定している（このテスト用）。

    # 回転量 s[j]（48ステップ分）
    s = [
        3, 7, 11, 19,  3, 7, 11, 19,  3, 7, 11, 19,  3, 7, 11, 19,   # Round1
        3, 5,  9, 13,   3, 5,  9, 13,   3, 5,  9, 13,   3, 5,  9, 13, # Round2
        3, 9, 11, 15,   3, 9, 11, 15,   3, 9, 11, 15,   3, 9, 11, 15  # Round3
    ]

    # メッセージワード参照順 t[j]（48ステップ分）
    t = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,          # Round1: 0..15
        0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15,          # Round2
        0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15           # Round3
    ]

    # 初期値（IV）
    a, b, c, d = a0, b0, c0, d0 = 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476

    # 2ブロック分処理（i=0 が z[0..15]、i=1 が z[16..31]）
    for i in range(2):
        # Round1（16ステップ）
        # 更新は (a,b,c,d) が回り込むように代入している:
        #   a <- d
        #   b <- rol(a + F(b,c,d) + X[k], s)
        #   c <- b_old
        #   d <- c_old
        for j in range(16):
            a, b, c, d = d, rol(((a + ff(b, c, d) + z[t[j] + 16 * i]) & 0xffffffff), s[j]), b, c

        # Round2（16ステップ）: +R2
        for j in range(16, 32):
            a, b, c, d = d, rol(((a + gg(b, c, d) + z[t[j] + 16 * i] + R2) & 0xffffffff), s[j]), b, c

        # Round3（16ステップ）: +R3
        for j in range(32, 48):
            a, b, c, d = d, rol(((a + hh(b, c, d) + z[t[j] + 16 * i] + R3) & 0xffffffff), s[j]), b, c

        # feed-forward（ブロックごとに初期状態を足し戻すことでチェーンする）
        a, b, c, d = a0, b0, c0, d0 = (
            (a + a0) & 0xffffffff,
            (b + b0) & 0xffffffff,
            (c + c0) & 0xffffffff,
            (d + d0) & 0xffffffff
        )

    # 出力（A,B,C,D を 128bit 整数にまとめて返す）
    # conv で表示用にバイト順を反転した値を連結している。
    return (conv(a & 0xffffffff) << 96) | (conv(b & 0xffffffff) << 64) | (conv(c & 0xffffffff) << 32) | conv(d & 0xffffffff)


# -----------------------------------------------------------------------------
# 2ブロック入力 z を手で構成する（x, y）
# -----------------------------------------------------------------------------
# x と y は 32ワード（2ブロック分）。
# y は x のコピーだが、y[12] を +1 した “1ワード差分” を入れている。
# これにより md4one(x) と md4one(y) の差（ハッシュ値の変化）を観察できる。

x = [0 for i in range(32)]
y = [0 for i in range(32)]

# x[0..4] は固定値（テスト用に与えられた初期ワード）
# ここは “メッセージの先頭 5ワード” に相当する。
x[0], x[1], x[2], x[3], x[4] = 0x9074449b, 0x1089fc26, 0x8bf37fa2, 0x1d630daf, 0x63247e24

# テスト文字列
# 先頭に改行があり、"CONTRACT" を含む。
txt = "\nCONTRACT\n\nAt the price of $176,495 Alf Blow"

# txt の先頭 44 文字（= 11 * 4）を 32bitワードに詰める
# - i=0..10 の 11ワードを生成し、x[5]..x[15] に配置
# - ord(txt[4*i+j]) を (8*j) だけシフトして OR するので little-endian で詰めている
#   例: 4文字 "ABCD" は 0x44434241 になる（Aが最下位バイト）。
for i in range(11):
    for j in range(4):
        x[i + 5] |= ord(txt[4 * i + j]) << (8 * j)

# y を x のコピー（最初の 16ワード分だけコピーしている）
for i in range(16):
    y[i] = x[i]

# y の 1ワードだけ変える（差分実験）
# - 32bit ワード y[12] に +1 を加える（mod 2^32）
# - MD4 の拡散（avalanche）を観察する意図
y[12] = (y[12] + 1) & 0xffffffff

# パディングの一部を手で設定
# x[16] と y[16] に 0x80 を入れているのは「2ブロック目の先頭ワードに 0x80 を置く」意味合い。
# ただし厳密なMD4パディングでは 0x80 は “次のバイト位置” に入るので、
# ここは「テスト用に構造を固定」した入力になっていると捉えるのが自然。
x[16] = y[16] = 0x80

# 長さ（ビット長）相当の値をセット
# x[30] / y[30] = 512 は「メッセージ長が 512bit」という設定に見える。
# MD4 のパディングでは最後の 64bit に bit長を little-endian で入れるので、
# これも “テスト専用の固定配置” として理解するのが良い。
x[30] = y[30] = 512

# -----------------------------------------------------------------------------
# 3) 計算と表示
# -----------------------------------------------------------------------------
# md4one は 128bit を整数で返すので、format(...,'08x') は本来桁数が足りない。
# ただしここは「上位が0でない場合も含めて表示したい」なら、'032x' を使うのが自然。
# （元コードは '08x' なので、表示の意図に合わせて読み替えが必要）
print(format(md4one(x), '08x'), format(md4one(y), '08x'))
