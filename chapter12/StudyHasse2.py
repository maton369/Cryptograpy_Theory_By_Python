# 有限体 F_p 上のランダム楕円曲線の点数 |E(F_p)| を数え、トレース t を散布図で描く（matplotlib版）
# -----------------------------------------------------------------------------
# 目的
# - 素数 p を多数サンプルし、各 p に対してランダムな係数 a,b を選んで
#
#     E: y^2 ≡ x^3 + a x + b (mod p)
#
#   を作る。
# - その曲線上の点の個数 |E(F_p)| を全探索（x=0..p-1）で数える。
# - 楕円曲線のトレース（trace）
#
#     t = p + 1 - |E(F_p)|
#
#   を計算し、(p, t) を散布図で可視化する。
#
# 背景（Hasse の定理）
# - 楕円曲線 E/F_p では点数が次を満たす：
#
#     ||E(F_p)| - (p+1)| <= 2*sqrt(p)
#
# したがってトレース t は
#
#     |t| <= 2*sqrt(p)
#
# に収まる。散布図で「t が sqrt(p) スケールに収まる」様子を直感的に確認する狙いがある。
#
# -----------------------------------------------------------------------------
# 注意（厳密性）
# -----------------------------------------------------------------------------
# - RandCurveGen(p) は a,b をランダムに選ぶだけなので、低確率で “特異曲線” が混ざる可能性がある。
#   楕円曲線として成立するには判別式 Δ が 0 でない必要がある：
#
#     Δ = -16(4a^3 + 27b^2) (mod p)
#     Δ != 0
#
#   これを満たさないと曲線は楕円曲線ではなく、点数分布も変わり得る。
#   学習用途ならそのままでもよいが、厳密な実験なら Δ!=0 をチェックして再抽選する。
#
# - RandPrimeGen は「num 回試行して素数だったものを集める」方式であり、
#   “num 個の素数を生成する” わけではない。また同じ素数が重複して入る可能性がある。
#
# - random は暗号用途の乱数ではない（学習・統計観察なら問題ない）。
#
# -----------------------------------------------------------------------------
# アルゴリズム（中心）
# -----------------------------------------------------------------------------
# 1) p をたくさん集める（5..500 から乱数→素数判定）
# 2) 各 p で a,b をランダムに選び曲線 E を作る
# 3) x を 0..p-1 で回し、RHS(x)=x^3+ax+b mod p の平方剰余性をルジャンドル記号で判定
#    - RHS が非平方剰余なら点なし
#    - RHS ≡ 0 なら y=0 の1点
#    - RHS が平方剰余なら y と -y の2点
# 4) 無限遠点を 1 点加えて |E(F_p)| を得る
# 5) t = p+1-|E(F_p)| を計算して散布図で表示


import random
import matplotlib.pyplot as plt
import sympy


def Legendre(a, p):
    # ルジャンドル記号 (a/p) を Euler の判定法で求める。
    #
    #   a^{(p-1)/2} mod p が
    #     0 -> a≡0
    #     1 -> 平方剰余
    #     p-1 -> -1 mod p -> 平方非剰余
    L = pow(a, (p - 1) // 2, p)
    if L == p - 1:
        L = -1
    return L


# -----------------------------------------------------------------------------
# 素数リスト生成（グローバルに溜める方式）
# -----------------------------------------------------------------------------
PrimeList = []

def RandPrimeGen(low, high, num=1000):
    # [low,high] から num 回乱数を引き、素数なら PrimeList に追加する。
    #
    # 注意：
    # - 返るリストの長さは num ではない（素数密度次第）。
    # - 同じ素数が重複して入る可能性がある。
    # - PrimeList がグローバルで、再呼び出しで追記され続ける。
    for _ in range(num):
        q = random.randint(low, high)
        if sympy.isprime(q):
            PrimeList.append(q)
    return PrimeList


def RandCurveGen(p):
    # 曲線パラメータ a,b を F_p の中から一様にランダム選択する。
    #（非特異条件 Δ!=0 をチェックしていない）
    a = random.randrange(p)
    b = random.randrange(p)
    return a, b


def f(x, a, b, p):
    # RHS(x) = x^3 + a x + b (mod p)
    return (x**3 + a * x + b) % p


def CountElements(a, b, p):
    # |E(F_p)| を全探索で数える。
    #
    # 各 x に対して y^2 ≡ RHS(x) を解くと、
    # - RHS が非平方剰余 -> 0 解
    # - RHS ≡ 0         -> 1 解（y=0）
    # - RHS が平方剰余  -> 2 解（±y）
    #
    # これをルジャンドル記号で判定して足し上げる。
    count0 = 0  # Legendre==0 の x の個数（y=0 の1点）
    count1 = 0  # Legendre==1 の x に対する点数寄与（2点ずつ加算）

    for x in range(p):
        ysq = f(x, a, b, p)
        Leg = Legendre(ysq, p)
        if Leg == 0:
            count0 += 1      # y=0 の 1 点
        elif Leg == 1:
            count1 += 2      # ±y の 2 点

    # 無限遠点（楕円曲線群の単位元）を +1
    total = count0 + count1 + 1
    return total


# -----------------------------------------------------------------------------
# 実験：p ごとにランダム曲線を作りトレース t を計算
# -----------------------------------------------------------------------------
numlist = []

# 5..500 の範囲で 50000 回試行して素数を拾う
plist = RandPrimeGen(5, 500, 50000)

for p in plist:
    a, b = RandCurveGen(p)
    Esize = CountElements(a, b, p)
    tr = p + 1 - Esize
    numlist.append(tr)

# -----------------------------------------------------------------------------
# 可視化
# -----------------------------------------------------------------------------
plt.scatter(plist, numlist)
plt.xlabel('p')
plt.ylabel('trace t = p + 1 - |E(F_p)|')
plt.show()
