# 有限体 F_p 上の「ランダム楕円曲線」の点数を数え、トレース t を散布図で可視化するコード
# -----------------------------------------------------------------------------
# 目的
# - 素数 p をランダムに取り、同じ p ごとにランダムな楕円曲線
#
#     E: y^2 ≡ x^3 + a x + b  (mod p)
#
#   を生成し、その曲線上の点の総数 |E(F_p)| を数える。
# - そして楕円曲線のトレース（trace）
#
#     t = p + 1 - |E(F_p)|
#
#   を計算して、(p, t) の散布図を描く。
#
# 背景（Hasse の定理）
# - 任意の楕円曲線 E/F_p に対して、点数は
#
#     | |E(F_p)| - (p+1) | <= 2*sqrt(p)
#
#   を満たす（Hasse の評価）。
# - したがってトレース t は
#
#     |t| <= 2*sqrt(p)
#
#   の範囲に収まる。
# - このコードは p を色々変えつつ t をプロットすることで、
#   “t が sqrt(p) スケールに収まっている” 直感を得る実験になっている。
#
# -----------------------------------------------------------------------------
# 重要な注意（このコードは「楕円曲線として有効」かをチェックしていない）
# -----------------------------------------------------------------------------
# 楕円曲線 y^2 = x^3 + ax + b が楕円曲線として成立する条件は判別式が 0 でないこと：
#
#     Δ = -16(4a^3 + 27b^2)  (mod p)
#     Δ != 0
#
# もし Δ == 0 だと曲線は特異（楕円曲線ではない）になり、点数分布や性質が変わる。
# 本コードの RandCurveGen(p) は a,b をランダムに選ぶだけなので、
# 低確率で特異曲線も混ざり得る（厳密にやるなら Δ!=0 をチェックして再抽選する）。
#
# -----------------------------------------------------------------------------
# アルゴリズム（中心）
# -----------------------------------------------------------------------------
# 1) low..high から乱数を引き、素数判定して “素数リスト” plist を作る
# 2) 各 p に対し a,b をランダムに選んで曲線 E を作る
# 3) x=0..p-1 を全探索して RHS を計算し、平方剰余性に応じて点数を足し上げる
# 4) |E(F_p)| を得たら t = p+1-|E(F_p)| を計算し numlist に入れる
# 5) (p, t) を散布図で可視化する
#
# 点数の数え上げのポイント
# - 各 x に対して y^2 ≡ RHS(x) を解く。
# - RHS(x) が平方剰余なら y は 2 解（±y）
# - RHS(x) ≡ 0 なら y は 1 解（y=0）
# - RHS(x) が平方非剰余なら解なし
# - 最後に “無限遠点” を 1 点加えて |E(F_p)| にする。
#
# つまり
#
#     |E(F_p)| = 1 + Σ_{x in F_p} ( 1 + (RHS(x)/p) )
#
# の形で書ける（(RHS/p) はルジャンドル記号）。
#
# -----------------------------------------------------------------------------
# ライブラリ
# -----------------------------------------------------------------------------
# - random : 擬似乱数（学習用）。暗号用途なら secrets が望ましい。
# - sympy  : isprime による素数判定
# - matplotlib.pyplot : 散布図描画


import random
from matplotlib import pyplot
import sympy


def Legendre(a, p):
    # ルジャンドル記号 (a/p) を Euler の判定法で計算する。
    #
    #   a^{(p-1)/2} mod p が
    #     0 -> a≡0
    #     1 -> QR（平方剰余）
    #     p-1 -> -1 mod p -> QNR（平方非剰余）
    L = pow(a, (p - 1) // 2, p)
    if L == p - 1:
        L = -1
    return L


# -----------------------------------------------------------------------------
# 1) 素数リスト生成
# -----------------------------------------------------------------------------
PrimeList = []  # 生成した素数を溜める（グローバル）

def RandPrimeGen(low, high, num=1000):
    # [low, high] の整数から num 回ランダムに引いて素数ならリストに追加する。
    #
    # 注意：
    # - “素数を num 個作る” ではなく “num 回試行して素数を拾う” なので、
    #   返るリストの長さは試行回数と素数密度に依存する。
    # - PrimeList がグローバルで、呼び出すたびに追記される点にも注意。
    for i in range(num):
        q = random.randint(low, high)
        if sympy.isprime(q):
            PrimeList.append(q)
    return PrimeList


# -----------------------------------------------------------------------------
# 2) ランダム曲線パラメータ生成
# -----------------------------------------------------------------------------
def RandCurveGen(p):
    # a,b を F_p の一様乱数として選ぶ。
    # ただし Δ!=0 のチェックをしていないので、特異曲線が混ざる可能性がある。
    Ran = [i for i in range(p)]
    a = random.choice(Ran)
    b = random.choice(Ran)
    return a, b


# -----------------------------------------------------------------------------
# 3) 曲線右辺 RHS(x) = x^3 + ax + b (mod p)
# -----------------------------------------------------------------------------
def f(x, a, b, p):
    ysq = (x**3 + a * x + b) % p
    return ysq


# -----------------------------------------------------------------------------
# 4) 点数 |E(F_p)| を数える
# -----------------------------------------------------------------------------
def CountElements(a, b, p):
    # 返り値：|E(F_p)|（無限遠点を含む）
    #
    # count0: RHS(x) ≡ 0 となる x の個数（このとき y=0 の1点）
    # count1: RHS(x) が平方剰余となる x の個数に対し、y は2点（±y）なので 2 を足す
    count0 = 0  # Legendre == 0 の個数
    count1 = 0  # Legendre == 1 の場合の “点数寄与” を 2 ずつ足す

    for x in range(p):
        ysq = f(x, a, b, p)
        Leg = Legendre(ysq, p)

        if Leg == 0:
            # y^2 ≡ 0 -> y=0 の1点
            count0 += 1
        elif Leg == 1:
            # y^2 ≡ ysq（平方剰余）-> y と -y の2点
            count1 += 2
        # Leg == -1 の場合は点なし

    # 無限遠点を 1 点加える（楕円曲線群の単位元）
    total = count0 + count1 + 1
    return total


# -----------------------------------------------------------------------------
# 5) 実験：p ごとにランダム曲線を作りトレース t を計算
# -----------------------------------------------------------------------------
numlist = []

# 素数候補の生成
# - 5..500 の範囲で 50000 回サンプルし、素数だったものを plist に集める
plist = RandPrimeGen(5, 500, 50000)

for p in plist:
    # 曲線パラメータをランダムに選ぶ
    a, b = RandCurveGen(p)

    # 点数 |E(F_p)| を数える
    Esize = CountElements(a, b, p)

    # トレース t = p + 1 - |E(F_p)|
    tr = p + 1 - Esize
    numlist.append(tr)

# -----------------------------------------------------------------------------
# 6) 可視化（散布図）
# -----------------------------------------------------------------------------
# x軸: p
# y軸: t = p+1-|E(F_p)|
# Hasse の評価により |t| <= 2*sqrt(p) に収まるはず、という観察を狙う。
pyplot.scatter(plist, numlist)
pyplot.show()
