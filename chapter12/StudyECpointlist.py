# 有限体 F_p 上の楕円曲線 E: y^2 ≡ x^3 + a x + b (mod p) の点を列挙するコード
# -----------------------------------------------------------------------------
# 目的
# - 具体的に小さな素数 p に対して、楕円曲線上の点集合 E(F_p) を「全列挙」して確認する。
# - ECC では通常 p は巨大だが、小さい p で列挙すると
#   「各 x に対して y が 0/1/2 個決まる」構造が直感的に理解できる。
#
# 対象の曲線
# - ここでは
#     p = 7, a = 0, b = 2
# なので
#
#     E: y^2 ≡ x^3 + 2  (mod 7)
#
# を扱う。
#
# -----------------------------------------------------------------------------
# アルゴリズム（中心）
# -----------------------------------------------------------------------------
# 1) x = 0..p-1 を総当たりする
# 2) RHS(x) = x^3 + a x + b (mod p) を計算する
# 3) RHS(x) が平方剰余（quadratic residue）かどうかをルジャンドル記号で判定する
#    - Legendre(RHS, p) ==  1 : 平方剰余 → y が 2 個（±y）
#    - Legendre(RHS, p) ==  0 : RHS=0    → y が 1 個（y=0）
#    - Legendre(RHS, p) == -1 : 非剰余  → y は存在しない
# 4) 点 (x,y) をリストに追加する
# 5) 最後に無限遠点（point at infinity）を追加して E(F_p) の点集合として完成させる
#
# -----------------------------------------------------------------------------
# ルジャンドル記号（平方剰余判定）
# -----------------------------------------------------------------------------
# 奇素数 p に対して Euler の判定法が成り立つ：
#
#   a^{(p-1)/2} ≡
#     0  (mod p)  if a≡0
#     1  (mod p)  if a is quadratic residue
#    -1  (mod p)  otherwise
#
# これを pow(a, (p-1)//2, p) で計算し、
# p-1 を -1 に直して {0,1,-1} の値として扱いやすくしている。
#
# -----------------------------------------------------------------------------
# modsqrt の前提（重要）
# -----------------------------------------------------------------------------
# modsqrt(c,p) は
#
#   y ≡ c^{(p+1)/4} (mod p)
#
# で平方根を計算している。
# これは
#
#   p ≡ 3 (mod 4)
#
# のときに成立する簡単ケースである。
#
# 今回 p=7 なので
#   7 % 4 = 3
# を満たし、正しく平方根が求まる。
#
# 注意：
# - p%4!=3 の場合は Tonelli–Shanks など一般アルゴリズムが必要になる。
#
# -----------------------------------------------------------------------------
# 無限遠点（point at infinity）
# -----------------------------------------------------------------------------
# 楕円曲線の点集合を群（アーベル群）として扱うとき、
# 単位元（0元）として無限遠点 O を 1 点加える。
# ここでは番兵として (-1,-1) を O とみなして points に追加する。
# （実際の座標ではなく “特別な記号” として扱う。）


def Legendre(a, p):
    # Euler 判定法でルジャンドル記号 (a/p) を計算する
    L = pow(a, (p - 1) // 2, p)
    # p-1 は -1 mod p を意味するので -1 に正規化する
    if L == p - 1:
        L = -1
    return L


def f(x, a, b, p):
    # RHS(x) = x^3 + a x + b (mod p) を返す
    # 曲線は y^2 ≡ RHS(x) (mod p)
    ysq = (x**3 + a * x + b) % p
    return ysq


# -----------------------------------------------------------------------------
# 曲線パラメータ（ここでは小さい例）
# -----------------------------------------------------------------------------
p = 7
a = 0
b = 2


def modsqrt(c, p):
    # p ≡ 3 (mod 4) のときの平方根（簡単ケース）
    # y = c^((p+1)/4) mod p が平方根になる（c が平方剰余である前提）
    return pow(c, (p + 1) // 4, p)


# -----------------------------------------------------------------------------
# 点の列挙
# -----------------------------------------------------------------------------
points = []

for x in range(p):
    # RHS(x) を計算
    ysq = f(x, a, b, p)

    # 平方剰余性を判定
    Leg = Legendre(ysq, p)

    if Leg == 1:
        # ysq が平方剰余なので平方根が存在する
        y = modsqrt(ysq, p)

        # 平方根は一般に 2 個：y と -y
        # mod p で -y は p-y として表せる
        points.append((x, y))
        points.append((x, p - y))

    elif Leg == 0:
        # ysq ≡ 0 の場合は y=0 の 1 点だけ
        points.append((x, 0))

    # Leg == -1 の場合は点なしなので追加しない

# 群の単位元として無限遠点を追加（番兵）
points.append((-1, -1))

# 列挙した点集合を表示
print(points)
