# 有限体 F_p 上の楕円曲線の点を描画し、ランダム点 P とそのスカラー倍 Q=kP を可視化する
# -----------------------------------------------------------------------------
# 目的
# - 楕円曲線暗号（ECC）の核心である「スカラー倍 kP」を実装し、
#   有限体上の点集合の中で “P がどの点へ写るか” を視覚的に確認する。
#
# このコードがやること
# 1) 素数 p 上の楕円曲線
#
#     E: y^2 ≡ x^3 + a x + b (mod p)
#
#   の点を全列挙して散布図で描く（灰色）。
# 2) その点集合からランダムに点 P を 1つ選ぶ（無限遠点を除く）。
# 3) double-and-add で Q = kP を計算し、P（★）と Q（◆）を強調表示する。
#
# -----------------------------------------------------------------------------
# パラメータ
# -----------------------------------------------------------------------------
# p=163, a=1, b=2, k=50
# 曲線は
#
#   y^2 ≡ x^3 + x + 2 (mod 163)
#
# となる。
#
# 注意（重要）
# - modsqrt は p%4==3 の簡単平方根計算を使っている：
#
#     y ≡ c^{(p+1)/4} (mod p)
#
#   これは p≡3(mod4) のときのみ成立する。
#   しかし p=163 は 163%4=3 なので OK。
#
# -----------------------------------------------------------------------------
# 実装上の注意（群演算の簡略化）
# -----------------------------------------------------------------------------
# - このコードの ECadd は「x座標が等しいなら無限遠点」としているが、
#   厳密には
#     - Q = -P のときのみ P+Q=O
#     - Q = P のときは倍算（ECdouble）
#   を区別する必要がある。
# - また Infty（無限遠点）は (-1,-1) を番兵として表している。
# - 学習・可視化目的では動きやすいが、一般の ECC 実装としては厳密化が必要。
#
# -----------------------------------------------------------------------------
# アルゴリズム（中心）
# -----------------------------------------------------------------------------
# 1) 各 x に対して RHS(x) を計算し、ルジャンドル記号で平方剰余性を判定
# 2) 平方剰余なら平方根 y を 1つ求め、±y の2点を追加
# 3) 点集合からランダムに P を選ぶ
# 4) ECmult(k,P) を double-and-add で計算し Q を得る
# 5) P と Q を図上で強調表示する


import matplotlib.pyplot as plt
import random


def Legendre(a, p):
    # ルジャンドル記号 (a/p) を Euler の判定法で計算する。
    # pow(a,(p-1)//2,p) は 0..p-1 の剰余で返るので、
    # p-1 を -1 に正規化して {0,1,-1} を返す。
    L = pow(a, (p - 1) // 2, p)
    if L == p - 1:
        L = -1
    return L


def f(x, a, b, p):
    # RHS(x) = x^3 + a x + b (mod p)
    # 曲線は y^2 ≡ RHS(x) (mod p)
    return (x**3 + a * x + b) % p


def modsqrt(c, p):
    # p ≡ 3 (mod 4) のときの平方根（簡単ケース）
    # c が平方剰余である前提で
    #   y = c^{(p+1)/4} mod p
    # が平方根になる。
    return pow(c, (p + 1) // 4, p)


def modinv(s, p):
    # 逆元 s^{-1} mod p（p は素数が前提）
    # s^{p-2} ≡ s^{-1} (mod p)
    return pow(s, p - 2, p)


def ECadd(P, Q):
    # 点の加算 R = P + Q（簡略版）
    #
    # 一般式（x_P != x_Q）：
    #   λ = (y_Q - y_P)/(x_Q - x_P)
    #   x_R = λ^2 - x_P - x_Q
    #   y_R = λ(x_P - x_R) - y_P
    #
    # 境界ケースの正しい扱いは本来もっと分岐が必要だが、
    # ここでは学習用に “x座標が同じなら O” としている。
    if Q[0] == P[0]:
        return (-1, -1)  # 無限遠点 O

    lam = ((Q[1] - P[1]) * modinv(Q[0] - P[0], p)) % p
    x3 = (lam**2 - P[0] - Q[0]) % p
    y3 = (lam * (P[0] - x3) - P[1]) % p
    return (x3, y3)


def ECdouble(P):
    # 点の倍算 R = 2P
    #
    # 倍算式（y_P != 0）：
    #   λ = (3x_P^2 + a)/(2y_P)
    #   x_R = λ^2 - 2x_P
    #   y_R = λ(x_P - x_R) - y_P
    #
    # y_P == 0 のとき接線が垂直になり 2P = O
    if (2 * P[1]) % p == 0:
        return (-1, -1)

    lam = ((3 * pow(P[0], 2, p) + a) * modinv(2 * P[1], p)) % p
    x3 = (pow(lam, 2, p) - 2 * P[0]) % p
    y3 = (lam * (P[0] - x3) - P[1]) % p
    return (x3, y3)


def ECmult(scalar, P):
    # スカラー倍 Q = scalar * P を double-and-add で計算する。
    #
    # scalar の2進表現を MSB→LSB で走査し、
    # - 毎回倍算
    # - ビットが1なら加算
    #
    # ここでは MSB が 1 であることを利用して point=P から始めている。
    if scalar == 0:
        return (-1, -1)

    scalar_bin = str(bin(scalar))[2:]
    point = P
    for i in range(1, len(scalar_bin)):
        point = ECdouble(point)
        if scalar_bin[i] == "1":
            point = ECadd(point, P)
    return point


# -----------------------------------------------------------------------------
# 曲線とスカラー
# -----------------------------------------------------------------------------
p = 163
a = 1
b = 2
k = 50

# -----------------------------------------------------------------------------
# 1) 点集合の列挙と描画（灰色）
# -----------------------------------------------------------------------------
points = []  # 無限遠点を除いた点のリスト（ランダム選択用）

for x in range(p):
    ysq = f(x, a, b, p)
    Leg = Legendre(ysq, p)

    if Leg == 1:
        # 平方剰余なので y が2つ（±y）
        y = modsqrt(ysq, p)

        # 点リストに追加（Pythonリスト形式で保持）
        points.append([x, y])
        points.append([x, p - y])

        # 描画（灰色）
        plt.scatter(x, y, s=10, c="gray")
        plt.scatter(x, p - y, s=10, c="gray")

    elif Leg == 0:
        # ysq ≡ 0 -> y=0 の1点
        points.append([x, 0])
        plt.scatter(x, 0, s=10, c="gray")

    # Leg == -1 の場合は点なし

# -----------------------------------------------------------------------------
# 2) ランダムに点 P を選び、Q = kP を計算して強調表示
# -----------------------------------------------------------------------------
P = random.choice(points)                 # 無限遠点を除いた点からランダム選択
plt.scatter(P[0], P[1], s=90, c="black", marker="*")  # P を ★ で表示

Q = ECmult(k, P)                          # Q = kP
plt.scatter(Q[0], Q[1], s=50, c="black", marker="D")  # Q を ◆ で表示

# -----------------------------------------------------------------------------
# 3) 表示
# -----------------------------------------------------------------------------
plt.show()
