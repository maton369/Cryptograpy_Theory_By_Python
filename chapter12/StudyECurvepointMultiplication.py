# 有限体 F_p 上の楕円曲線の群演算（加算・倍算・スカラー倍）と位数 ord(P) の確認
# -----------------------------------------------------------------------------
# 目的
# - 楕円曲線暗号（ECC）の中核である「点の加算」「点の倍算」「スカラー倍（kP）」を実装する。
# - 与えられた点 P に対して、P, 2P, 3P, ... を計算し、最初に無限遠点 O に戻る i を探して
#   位数 ord(P) を求める。
#
# 楕円曲線（Weierstrass 形式）
# - このコードが想定している曲線は（有限体 F_p 上で）
#
#     E: y^2 ≡ x^3 + a x + b  (mod p)
#
# である。
#
# 群としての性質
# - 楕円曲線上の点集合 E(F_p) は「点の加算」によりアーベル群をなす。
# - 単位元（加法の 0 に相当）は “無限遠点” O（point at infinity）で表される。
#
# -----------------------------------------------------------------------------
# 注意（このコードの前提と簡略化）
# -----------------------------------------------------------------------------
# 1) p は素数である必要がある（modinv でフェルマーの小定理を使うため）
# 2) 点演算は “曲線上の点 P,Q が正しい” という前提で進む（曲線上チェックはしていない）
# 3) ECadd の分岐は簡略化されている：
#    - Q[0] == P[0] のとき常に無限遠点を返しているが、
#      正しくは
#        - Q == -P のとき P+Q=O
#        - Q == P のときは倍算（ECdouble）を使う
#      という扱いになる。
#    - このコードは ECmult 内で「加算は point と P（固定P）」のみが使われる形で、
#      iP の系列の確認としては動きやすいが、一般の加算としては不完全になり得る。
#
# 4) ECmult は “左から右” の二進法（double-and-add）で kP を計算するが、
#    初期化が point=P で、最上位ビットをすでに処理した前提の書き方になっている。
#    scalar=0 のときだけ O を返し、それ以外はビット列を走査する典型パターン。
#
# -----------------------------------------------------------------------------
# 位数の探索に MAX を使う理由（Hasse の評価）
# -----------------------------------------------------------------------------
# 楕円曲線の点数 |E(F_p)| は Hasse の評価で
#
#   | |E(F_p)| - (p+1) | <= 2*sqrt(p)
#
# よって
#
#   |E(F_p)| <= p + 1 + 2*sqrt(p)
#
# このコードの
#   MAX = p+1+2*ceil(sqrt(p))
# は “群のサイズの上限” を目安にして、そこまで iP を見れば
# 必ず周期（位数）に到達するだろう、という見積もりになっている。
#
# -----------------------------------------------------------------------------
# 実装する演算
# -----------------------------------------------------------------------------
# - modinv(s, p): s^{-1} mod p（逆元）
# - ECadd(P, Q): 点の加算 P+Q
# - ECdouble(P): 点の倍算 2P
# - ECmult(k, P): スカラー倍 kP（double-and-add）
#
# 無限遠点（単位元）
# - Infty = (-1,-1) として表す（実際の座標ではなく “番兵”）。
#   計算途中でこの値が出たら “O” とみなす。


import math

Infty = (-1, -1)  # point at infinity（無限遠点 O を表す番兵）


def modinv(s, p):
    # mod p における逆元 s^{-1} を返す（p は素数が前提）
    #
    # フェルマーの小定理：
    #   s^{p-1} ≡ 1 (mod p)  （s≠0 mod p）
    # より
    #   s^{p-2} ≡ s^{-1} (mod p)
    #
    # 注意：
    # - s≡0 mod p のとき逆元は存在しない（ここでは呼ばれない前提）。
    return pow(s, p - 2, p)


def ECadd(P, Q):
    # 点の加算 R = P + Q を計算する（有限体 F_p 上）
    #
    # 代表的な加算則（P≠±Q の一般ケース）：
    #   λ = (y_Q - y_P) / (x_Q - x_P)
    #   x_R = λ^2 - x_P - x_Q
    #   y_R = λ(x_P - x_R) - y_P
    # すべて mod p で計算する。
    #
    # 境界ケース：
    # - P = O なら P+Q = Q
    # - Q = O なら P+Q = P
    # - x_P = x_Q かつ y_P = -y_Q なら P+Q = O（縦線で交わる）
    # - P = Q のときは倍算（ECdouble）を使うのが一般的
    if P == Infty:
        return Q
    elif Q == Infty:
        return P

    # 簡略化された判定：x座標が等しければ無限遠点
    # 厳密には
    # - Q == P の場合は倍算に回す
    # - Q == -P の場合は O
    # を区別する必要がある。
    elif Q[0] == P[0]:
        return Infty

    # 一般ケースの傾き λ を計算
    lam = ((Q[1] - P[1]) * modinv(Q[0] - P[0], p)) % p

    # x3, y3 を計算（mod p）
    x3 = ((lam**2) - P[0] - Q[0]) % p
    y3 = (lam * (P[0] - x3) - P[1]) % p
    return (x3, y3)


def ECdouble(P):
    # 点の倍算 R = 2P を計算する（有限体 F_p 上）
    #
    # 倍算則（y_P ≠ 0 のとき）：
    #   λ = (3x_P^2 + a) / (2y_P)
    #   x_R = λ^2 - 2x_P
    #   y_R = λ(x_P - x_R) - y_P
    #
    # 境界ケース：
    # - P = O なら 2P = O
    # - y_P = 0（2y_P≡0）なら接線が垂直になり 2P = O
    if P == Infty:
        return Infty
    elif (2 * P[1]) % p == 0:
        return Infty

    # 傾き λ を計算
    lam = ((3 * pow(P[0], 2, p) + a) * modinv(2 * P[1], p)) % p

    # x3, y3 を計算
    x3 = (pow(lam, 2, p) - 2 * P[0]) % p
    y3 = (lam * (P[0] - x3) - P[1]) % p
    return (x3, y3)


def ECmult(scalar, P):
    # スカラー倍 Q = scalar * P を double-and-add で計算する。
    #
    # 二進法（左から右）の考え方：
    # - scalar の2進表現を MSB→LSB で走査する。
    # - 各ビットで「倍算」を行い、ビットが1ならさらに P を加算する。
    #
    # 典型形の一つ：
    #   Q = O
    #   for bit in bits:
    #       Q = 2Q
    #       if bit==1: Q = Q + P
    #
    # この実装は “最上位ビットは必ず1” を利用して
    #   point = P
    # から始め、残りビットを処理する形になっている。
    if scalar == 0:
        return Infty

    scalar_bin = str(bin(scalar))[2:]  # '0b...' を除いたビット列
    point = P                          # MSB=1 をすでに反映した状態から開始
    slen = len(scalar_bin)

    # i=1 から走査する（最初のビットは処理済み扱い）
    for i in range(1, slen):
        point = ECdouble(point)        # 1ビット進むたびに倍算
        if scalar_bin[i] == "1":
            point = ECadd(point, P)    # ビットが1なら P を加算
    return point


# -----------------------------------------------------------------------------
# パラメータ設定（曲線と点）
# -----------------------------------------------------------------------------
# 例1（コメントアウト）:
# p = 23; a = 1; b = 0
# P = (13, 18)
#
# 例2（実行する設定）:
p = 11
a = 0
b = 3
P = (4, 1)

# -----------------------------------------------------------------------------
# 位数 ord(P) の探索
# -----------------------------------------------------------------------------
# Hasse の評価より |E(F_p)| <= p+1+2*sqrt(p)。
# 点 P の位数 ord(P) は群のサイズ |E(F_p)| を割るので、同様にこの上限以内に収まる。
MAX = p + 1 + 2 * math.ceil(math.sqrt(p))

Plist = []
for i in range(1, MAX + 1):
    # iP を計算
    Q = ECmult(i, P)
    Plist.append(Q)

    # 無限遠点 O に戻ったら i が位数
    if (Q[0] == -1) and (Q[1] == -1):
        print(Plist)           # P,2P,...,O までの列
        print('ord(P) =', i)   # 位数
        break
