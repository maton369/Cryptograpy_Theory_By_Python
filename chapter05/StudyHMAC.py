# HMAC-SHA256 によるメッセージ認証コード（MAC）生成の最小例
# -----------------------------------------------------------------------------
# このコードは、共有秘密鍵 key とメッセージ message を入力として、
# HMAC（Hash-based Message Authentication Code）を計算し、
# その結果（認証タグ）を 16進文字列で表示する。
#
# -----------------------------------------------------------------------------
# 1) 何のためのものか（暗号理論の観点）
# -----------------------------------------------------------------------------
# HMAC は「改ざん検知 + 送信者の正当性確認（鍵を知っていること）」に使う。
#
# - 送信者と受信者が “同じ秘密鍵” を共有しているとき、
#   送信者は (message, tag) を送る。
# - 受信者は同じ鍵で HMAC を再計算し、tag が一致するか確認する。
# - 一致しなければ、メッセージが改ざんされたか、鍵を知らない第三者が偽造した可能性が高い。
#
# 重要:
# - HMAC は「暗号化」ではない（内容を隠さない）。
#   メッセージはそのまま読めるが、「改ざんされていないこと」を保証する道具である。
# - 内容も隠したいなら「暗号化 + 認証」または AEAD（AES-GCM など）を使う。
#
# -----------------------------------------------------------------------------
# 2) なぜ sha256(message) をそのまま使わないのか
# -----------------------------------------------------------------------------
# 「sha256(key || message)」のような単純な連結は、
# ハッシュ関数の構造（Merkle-Damgård）によって length extension attack などの問題が起こり得る。
# HMAC はこの問題を避けつつ、ハッシュ関数を MAC として安全に使える形に整形した方式である。
#
# （概念的には）
#   HMAC(K, m) = H( (K ⊕ opad) || H( (K ⊕ ipad) || m ) )
# という2段ハッシュになっており、内部状態の延長攻撃などに強い設計になっている。
#
# -----------------------------------------------------------------------------
# 3) ライブラリ（使い方の観点）
# -----------------------------------------------------------------------------
# Python 標準の hmac モジュールは HMAC を正しく実装している。
# - hmac.new(key, msg, digestmod) で HMAC オブジェクトを作り、
#   digest() / hexdigest() で結果を得る。
#
# hashlib.sha256 も標準のハッシュ関数実装で、ここでは digestmod として利用する。
#
# -----------------------------------------------------------------------------
# 4) 実装上の注意
# -----------------------------------------------------------------------------
# - key と message は bytes で渡す必要がある（str の場合は .encode() する）。
# - tag（署名）の比較は実務では「タイミング攻撃」を避けるため hmac.compare_digest を使うのが定石。


from hashlib import sha256  # SHA-256（ハッシュ関数）を HMAC の digestmod として指定するために読み込む
import hmac                 # HMAC 計算（標準ライブラリ）

# 共有秘密鍵（MAC 用）
# - 実務では推測困難な十分長い鍵（例: 32バイト以上）をランダムに生成して使うことが多い。
key = b'secret'

# 認証したいメッセージ（改ざん検知したい対象）
message = b'We learn from history that we do not learn from history.'

# HMAC-SHA256 の計算
# - hmac.new(key, message, sha256) で HMAC オブジェクト生成
# - .hexdigest() で 16進文字列として取得
#
# 出力は 256bit（32バイト）なので、hexdigest は 64文字になる。
signature = hmac.new(key, message, sha256).hexdigest()

# 結果表示（HMACタグ）
print(signature)

# -----------------------------------------------------------------------------
# 追加メモ（検証側の典型）
# -----------------------------------------------------------------------------
# 受信者側では次のように再計算し、一定時間比較で検証するのが定石：
#
#   expected = hmac.new(key, message, sha256).digest()
#   ok = hmac.compare_digest(expected, received_tag_bytes)
#
# compare_digest を使うことで、タグが途中まで一致しているかどうかで
# 処理時間が変わるような攻撃（タイミング攻撃）を避けられる。
