### Birthday Paradox（誕生日のパラドックス）シミュレーション
# -----------------------------------------------------------------------------
# 目的
# - 「n 人いると、同じ誕生日のペアが少なくとも1組存在する確率」をモンテカルロ法で推定する。
# - さらに、解析的近似
#     1 - exp( - n^2 / (2 * 365) )
#   と比較し、シミュレーション結果が近似式にどれくらい一致するか可視化する。
#
# 背景（誕生日のパラドックス）
# - 直感では「365日あるから、同じ誕生日が出るにはかなり大人数が必要」と思いがちだが、
#   実際は n=23 人程度で「同じ誕生日がいる確率」が 50% を超えることで有名。
#
# ここでの前提（モデル化）
# - 誕生日は 1〜365 の一様分布（全日が同確率）と仮定する。
# - うるう年（2/29）は無視する。
# - 各人の誕生日は独立と仮定する。
#   ※現実の誕生日分布は一様ではないが、理論の基本形としてよく使われる。

import random
import matplotlib.pyplot as plt
import numpy as np

# -----------------------------------------------------------------------------
# 日付集合 L を作る
# -----------------------------------------------------------------------------
# Days = [1, 2, ..., 365]
# 1日〜365日を「誕生日の候補」として表現する（実際の日付ではなく番号で良い）。
Days = list(range(1, 365 + 1))

# -----------------------------------------------------------------------------
# matchcount: 「popul 人の集団に、誕生日が一致する人がいる確率」を推定する関数
# -----------------------------------------------------------------------------
def matchcount(L, popul, Trials):
    """
    L      : 誕生日候補のリスト（ここでは 1..365）
    popul  : 人数 n
    Trials : 試行回数（モンテカルロ回数）

    戻り値 : 「少なくとも1組の誕生日一致が起きた割合」= 推定確率

    アルゴリズム
    - Trials 回繰り返して：
        1) popul 人の誕生日を L からランダムにサンプリングする（復元抽出）
        2) 重複（同じ誕生日）があれば match を +1
    - match / Trials を確率推定値として返す

    重複判定の考え方
    - Birthdays の長さが len(Birthdays)
    - set(Birthdays) は重複を消した集合なので、その長さ len(set(Birthdays)) は「異なる誕生日の数」
    - もし重複があれば、異なる誕生日数は人数より小さくなる
        len(Birthdays) > len(set(Birthdays))
      これが「同じ誕生日が少なくとも1回出た」の判定になる
    """
    match = 0  # 重複が起きた試行回数をカウント

    for i in range(Trials):
        # random.choices(L, k=popul) は L から k 個を「復元抽出」する。
        # - 復元抽出なので同じ値（同じ誕生日）が複数回出てもOK
        # - 誕生日モデルでは「人ごとの誕生日は独立で同じ日があり得る」ので、復元抽出が正しい
        Birthdays = list(random.choices(L, k=popul))

        # 重複があるか（同じ誕生日が少なくとも1組いるか）を判定
        if len(Birthdays) > len(set(Birthdays)):
            match += 1

    # Trials 回中 match 回で重複が起きたので、その比率が推定確率
    return match / Trials


# -----------------------------------------------------------------------------
# シミュレーション設定
# -----------------------------------------------------------------------------
Trials = 100   # 各人数 n についてのモンテカルロ試行回数（増やすほど精度は上がるが遅くなる）
MAX = 100      # 人数の上限（2〜MAX-1 を調べる）

# -----------------------------------------------------------------------------
# 人数 k を変えながら確率を推定する
# -----------------------------------------------------------------------------
ratio = []  # ratio[k-2] に「人数 k のときの一致確率（推定）」を入れる（k は 2..MAX-1）

for k in range(2, MAX):
    # 各 k について matchcount を呼び、確率を推定して保存
    ratio.append(matchcount(Days, k, Trials))

# x軸用の人数配列（2..MAX-1）
population = np.arange(2, MAX)

# -----------------------------------------------------------------------------
# 理論近似（解析式）との比較
# -----------------------------------------------------------------------------
# 誕生日問題の「一致が起きない確率」は厳密には
#   P(no collision) = 365/365 * 364/365 * 363/365 * ... * (365-n+1)/365
# である（n <= 365）。
#
# 一方、大きな 365 に対して n がそこまで大きくないとき、
#   P(no collision) ≈ exp( - n(n-1) / (2*365) )
# という近似が知られている（対数を取ってテイラー展開する導出が多い）。
#
# さらに n がそこそこ大きいと、n(n-1) ≈ n^2 として
#   P(collision) = 1 - P(no collision)
#              ≈ 1 - exp( - n^2 / (2*365) )
# が「手軽な近似式」としてよく使われる。
#
# このコードではその簡易形
#   1 - exp(-population**2/(2*365))
# を描画して、シミュレーション結果と比較する。

# -----------------------------------------------------------------------------
# 可視化
# -----------------------------------------------------------------------------
# 1本目：シミュレーション（モンテカルロ推定）
plt.plot(population, ratio)

# 2本目：近似式（解析近似）
plt.plot(population, 1 - np.exp(-population**2 / (2 * 365)))

# 軸ラベル
plt.xlabel('number of people')     # 人数 n
plt.ylabel('probability')          # 同じ誕生日がいる確率

# グラフ表示
plt.show()

# -----------------------------------------------------------------------------
# 追加メモ（改善・発展）
# -----------------------------------------------------------------------------
# - Trials=100 だと推定のブレ（分散）がやや大きい場合がある。
#   1000〜10000 に増やすと滑らかになる（計算時間は増える）。
# - 近似式は n(n-1) を使う方が少し良い近似になることが多い：
#     1 - exp( - n*(n-1) / (2*365) )
# - 厳密値も計算して3本目として重ねると、「厳密 vs 近似 vs 実験」が比較できる。
