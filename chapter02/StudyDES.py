# DES (Data Encryption Standard) 実装（ビット演算ベース）
# -----------------------------------------------------------------------------
# 使い方（想定）
#   subkeys = keyschedule(key64)
#   ctext   = encryption(ptext64, subkeys)      # 暗号化
#   ptext   = encryption(ctext64, subkeys[::-1])# 復号（サブ鍵を逆順にする）
#
# 入力の前提
# - plaintext（平文）: 64 bit 整数
# - key（鍵）        : 64 bit 整数
#   ※本来の DES 鍵は 64bit だが、うち 8bit はパリティビット（各7bitごとに1bit）である。
#   この実装は「パリティビットの整合性チェック」を行わず、そのまま 64bit を受け取る。
#
# このコードの位置づけ
# - DES の仕組み（Feistel構造、置換・展開、S-box、鍵スケジュール）を理解する学習用の実装である。
# - 現代の暗号用途に DES を使うのは推奨されない（鍵長56bitが短く総当たりが現実的）。
#   ただし「古典的ブロック暗号の設計」を理解する教材としては重要である。
#
# 実装方針
# - Python の整数をビット列として扱い、テーブル（IP, E, P, PC1, PC2, S-box）に従って
#   ビットを取り出して並べ替える（Permutation）処理を行う。
# - DES の各種テーブルは 1-indexed（仕様のビット番号）で与えられるため、
#   シフト量の計算でそのズレを吸収している。
#
# -----------------------------------------------------------------------------
# DES の全体像（アルゴリズムの流れ）
# -----------------------------------------------------------------------------
#
#   plaintext(64)
#        |
#        v
#    Initial Permutation (IP)  64 -> 64
#        |
#        v
#   L0(32) || R0(32)
#        |
#        |  for i = 1..16
#        |     Li = Ri-1
#        |     Ri = Li-1 XOR F(Ri-1, Ki)
#        v
#   L16 || R16
#        |
#        v
#    Swap (R16 || L16)   ※最終で左右を入れ替える
#        |
#        v
#   Inverse IP (IP^-1)
#        |
#        v
#   ciphertext(64)
#
# F 関数（DESの中核）
#
#   R(32)
#     |
#     v
#   Expansion E: 32 -> 48   （一部ビットを重複させて展開）
#     |
#     v
#   XOR with subkey K(48)
#     |
#     v
#   S-box: 48 -> 32         （6bit×8ブロックを4bit×8に圧縮）
#     |
#     v
#   Permutation P: 32 -> 32 （ビット並べ替え）
#     |
#     v
#   F(R,K) (32)
#
# 鍵スケジュール（key schedule）
# - 64bit鍵から PC1 で 56bit 抽出
# - 28bitずつ C,D に分割し、ラウンドごとに左回転
# - PC2 により 48bit のサブ鍵 Ki を生成（16個）
#
# -----------------------------------------------------------------------------
# 以降は DES の仕様テーブル群（定数）
# -----------------------------------------------------------------------------

# Initial Permutation (IP): 64-bit 入力のビットを並べ替えるテーブル
IP = [58, 50, 42, 34, 26, 18, 10, 2,
      60, 52, 44, 36, 28, 20, 12, 4,
      62, 54, 46, 38, 30, 22, 14, 6,
      64, 56, 48, 40, 32, 24, 16, 8,
      57, 49, 41, 33, 25, 17,  9, 1,
      59, 51, 43, 35, 27, 19, 11, 3,
      61, 53, 45, 37, 29, 21, 13, 5,
      63, 55, 47, 39, 31, 23, 15, 7]

# Inverse Initial Permutation (IP^-1): 最後に IP を元に戻す並べ替え
IPinv = [40, 8, 48, 16, 56, 24, 64, 32,
         39, 7, 47, 15, 55, 23, 63, 31,
         38, 6, 46, 14, 54, 22, 62, 30,
         37, 5, 45, 13, 53, 21, 61, 29,
         36, 4, 44, 12, 52, 20, 60, 28,
         35, 3, 43, 11, 51, 19, 59, 27,
         34, 2, 42, 10, 50, 18, 58, 26,
         33, 1, 41,  9, 49, 17, 57, 25]

# Expansion Permutation E: 32 -> 48 に展開するテーブル
# - 両端ビットを重複させる（隣接6bitブロックの境界で重複が起きる）
E = [32, 1, 2, 3, 4, 5,
      4, 5, 6, 7, 8, 9,
      8, 9,10,11,12,13,
     12,13,14,15,16,17,
     16,17,18,19,20,21,
     20,21,22,23,24,25,
     24,25,26,27,28,29,
     28,29,30,31,32, 1]

# S-box 群: 6bit -> 4bit の非線形置換を行う（8個ある）
# - 48bit を 6bit×8 ブロックに分割して、それぞれ対応する S-box を通す
# - 各 S-box は 4×16 の表（行は2bit, 列は4bit）で値が決まる
S = [  # S1
     [[14, 4,13, 1, 2,15,11, 8, 3,10, 6,12, 5, 9, 0, 7],
      [ 0,15, 7, 4,14, 2,13, 1,10, 6,12,11, 9, 5, 3, 8],
      [ 4, 1,14, 8,13, 6, 2,11,15,12, 9, 7, 3,10, 5, 0],
      [15,12, 8, 2, 4, 9, 1, 7, 5,11, 3,14,10, 0, 6,13]],
      # S2
     [[15, 1, 8,14, 6,11, 3, 4, 9, 7, 2,13,12, 0, 5,10],
      [ 3,13, 4, 7,15, 2, 8,14,12, 0, 1,10, 6, 9,11, 5],
      [ 0,14, 7,11,10, 4,13, 1, 5, 8,12, 6, 9, 3, 2,15],
      [13, 8,10, 1, 3,15, 4, 2,11, 6, 7,12, 0, 5,14, 9]],
      # S3
     [[10, 0, 9,14, 6, 3,15, 5, 1,13,12, 7,11, 4, 2, 8],
      [13, 7, 0, 9, 3, 4, 6,10, 2, 8, 5,14,12,11,15, 1],
      [13, 6, 4, 9, 8,15, 3, 0,11, 1, 2,12, 5,10,14, 7],
      [ 1,10,13, 0, 6, 9, 8, 7, 4,15,14, 3,11, 5, 2,12]],
      # S4
     [[ 7,13,14, 3, 0, 6, 9,10, 1, 2, 8, 5,11,12, 4,15],
      [13, 8,11, 5, 6,15, 0, 3, 4, 7, 2,12, 1,10,14, 9],
      [10, 6, 9, 0,12,11, 7,13,15, 1, 3,14, 5, 2, 8, 4],
      [ 3,15, 0, 6,10, 1,13, 8, 9, 4, 5,11,12, 7, 2,14]],
      # S5
     [[ 2,12, 4, 1, 7,10,11, 6, 8, 5, 3,15,13, 0,14, 9],
      [14,11, 2,12, 4, 7,13, 1, 5, 0,15,10, 3, 9, 8, 6],
      [ 4, 2, 1,11,10,13, 7, 8,15, 9,12, 5, 6, 3, 0,14],
      [11, 8,12, 7, 1,14, 2,13, 6,15, 0, 9,10, 4, 5, 3]],
      # S6
     [[12, 1,10,15, 9, 2, 6, 8, 0,13, 3, 4,14, 7, 5,11],
      [10,15, 4, 2, 7,12, 9, 5, 6, 1,13,14, 0,11, 3, 8],
      [ 9,14,15, 5, 2, 8,12, 3, 7, 0, 4,10, 1,13,11, 6],
      [ 4, 3, 2,12, 9, 5,15,10,11,14, 1, 7, 6, 0, 8,13]],
      # S7
     [[ 4,11, 2,14,15, 0, 8,13, 3,12, 9, 7, 5,10, 6, 1],
      [13, 0,11, 7, 4, 9, 1,10,14, 3, 5,12, 2,15, 8, 6],
      [ 1, 4,11,13,12, 3, 7,14,10,15, 6, 8, 0, 5, 9, 2],
      [ 6,11,13, 8, 1, 4,10, 7, 9, 5, 0,15,14, 2, 3,12]],
      # S8
     [[13, 2, 8, 4, 6,15,11, 1,10, 9, 3,14, 5, 0,12, 7],
      [ 1,15,13, 8,10, 3, 7, 4,12, 5, 6,11, 0,14, 9, 2],
      [ 7,11, 4, 1, 9,12,14, 2, 0, 6,10,13,15, 3, 5, 8],
      [ 2, 1,14, 7, 4,10, 8,13,15,12, 9, 0, 3, 5, 6,11]]]

# Permutation P: S-box 出力(32bit)を並べ替える（拡散を強める）
P = [16, 7,20,21,29,12,28,17,
     1,15,23,26, 5,18,31,10,
     2, 8,24,14,32,27, 3, 9,
    19,13,30, 6,22,11, 4,25]

# 鍵スケジュール用テーブル
# PC1: 64bit鍵から 56bit を選ぶ（パリティビットを落とす）
PC1 = [57,49,41,33,25,17, 9,
        1,58,50,42,34,26,18,
       10, 2,59,51,43,35,27,
       19,11, 3,60,52,44,36,
       63,55,47,39,31,23,15,
        7,62,54,46,38,30,22,
       14, 6,61,53,45,37,29,
       21,13, 5,28,20,12, 4]

# PC2: 56bit(C||D) から 48bit を選んでサブ鍵にする
PC2 = [14,17,11,24, 1, 5,
        3,28,15, 6,21,10,
       23,19,12, 4,26, 8,
       16, 7,27,20,13, 2,
       41,52,31,37,47,55,
       30,40,51,45,33,48,
       44,49,39,56,34,53,
       46,42,50,36,29,32]

# DES は 16 ラウンド（= 16 個のサブ鍵）
fullround = 16

# -----------------------------------------------------------------------------
# key schedule function
# input:  64bit key（パリティ無視）
# output: 48bit subkey を 16 個格納したリスト
# -----------------------------------------------------------------------------
def keyschedule(key):
    # 左回転数（各ラウンドで C と D を何ビット左回転するか）
    # DES の仕様で固定されている。
    sft = [1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1]

    # PC1 の結果（56bit）を int_key に構築する
    int_key = 0

    # 1<<64 を「64bit の最上位ビット+1」を指す基準として使い、
    # base64bit >> k で「k番目（1-indexed）に相当するビット位置」を作る。
    # ※この実装は「テーブル値が 1..64」の仕様に合わせてシフトしている。
    base64bit = 1 << 64  # = 2**64

    # PC1(key): 64bit鍵から 56bit を取り出し、順序を並べ替える処理
    # - PC1[i] が「元の鍵の何番目のビットを取るか」を表す
    # - 取り出したビットを int_key の適切な位置へ配置していく
    #
    # 実装上のポイント:
    # - (key & pos) で 1bit を抽出
    # - そのビットを左シフト/右シフトして「出力側の i 番目」に持っていく
    # - 途中の (i+8) は 64->56 に落とす際の位置合わせに由来する（ここが一番読みづらい）
    for i in range(len(PC1)):
        pos = base64bit >> PC1[i]
        int_key = int_key | (((key & pos) << (PC1[i]-1)) >> (i+8))

    # 28bit マスク（C と D は 28bit）
    MASK28 = 0xFFFFFFF

    # int_key(56bit) を C(28) と D(28) に分割
    LKey = int_key >> 28       # C0（左側28bit）
    RKey = int_key & MASK28    # D0（右側28bit）

    subkeys = []
    for i in range(fullround):
        # ---- C の左回転（28bitの循環シフト）----
        # C0 = (LKey << sft[i]) & MASK28 : 左へシフトした下位28bit
        # C1 = LKey >> (28 - sft[i])     : 左に溢れた上位ビットを下位へ回す分
        # LKey = C0 | C1                 : 結合して循環シフト完成
        C0 = (LKey << sft[i]) & MASK28
        C1 = LKey >> (28 - sft[i])
        LKey = C0 | C1

        # ---- D の左回転（同様）----
        D0 = (RKey << sft[i]) & MASK28
        D1 = RKey >> (28 - sft[i])
        RKey = D0 | D1

        # C||D を 56bit として結合
        CD = (LKey << 28) | RKey

        # PC2: 56bit(CD) から 48bit を抽出してサブ鍵 K_i を作る
        K = 0
        for j in range(len(PC2)):
            # 1<<(56-PC2[j]) で「CD の PC2[j] 番目ビット」を取り出す位置を作る
            pos = 1 << (56 - PC2[j])
            # 抽出したビットを K の j 番目へ配置する（位置合わせのシフトが入る）
            K = K | ((CD & pos) << (PC2[j]-1) >> (j+8))

        subkeys.append(K)  # 48bit サブ鍵を保存

    return subkeys


# -----------------------------------------------------------------------------
# IP: Initial Permutation を適用して 64bit を並べ替える
# -----------------------------------------------------------------------------
def IPread(plaintext):
    base64bit = 1 << 64
    int_txt = 0  # IP 適用後の 64bit ブロック
    for i in range(len(IP)):
        pos = base64bit >> IP[i]  # plaintext の IP[i] 番目ビットを指すマスク
        # 抽出ビットを出力側 i 番目へ移動して OR で詰める
        int_txt = int_txt | (((plaintext & pos) << (IP[i]-1)) >> i)
    return int_txt


# -----------------------------------------------------------------------------
# E: Expansion Permutation（32->48）を適用
# -----------------------------------------------------------------------------
def Eread(R):
    base32bit = 1 << 32
    ER = 0
    for j in range(len(E)):
        pos = base32bit >> E[j]  # R の E[j] 番目ビットを指すマスク
        # 48bit 出力 ER の j 番目へ配置する（ここも位置合わせがややトリッキー）
        ER = ER | ((R & pos) << (E[j]-1) << 16 >> j)
    return ER


# -----------------------------------------------------------------------------
# S-box 適用: j番目S-box に 6bit 入力 → 4bit 出力
# -----------------------------------------------------------------------------
def Sboxread(j, bits):
    # DES の S-box 入力 6bit は b5 b4 b3 b2 b1 b0 とすると、
    # - row（行）は外側2bit (b5, b0)
    # - col（列）は内側4bit (b4 b3 b2 b1)
    #
    # ここでのコードは「row/col の取り出し」をビット演算で行っている。
    #
    # 注意:
    # - 変数名 col/row が一般的な定義と逆に見えるが、
    #   後段の S[j][col][row] というアクセスに合わせている実装になっている。
    #   （多くの説明では S[row][col] と書くことが多いので読み替えに注意）
    col = (bits & 0b100000) >> 4 | (bits & 0b000001)  # 外側2bit → 0..3
    row = (bits & 0b011110) >> 1                      # 内側4bit → 0..15

    # S-box テーブルから 4bit 値を取得
    val = S[j][col][row]
    return val


# -----------------------------------------------------------------------------
# P: 32bit を並べ替える Permutation（F関数の最後）
# -----------------------------------------------------------------------------
def Pread(Sout):
    base32bit = 1 << 32
    PF = 0
    for n in range(len(P)):
        pos = base32bit >> P[n]  # Sout の P[n] 番目ビット
        PF = PF | ((Sout & pos) << (P[n]-1) >> n)
    return PF


# -----------------------------------------------------------------------------
# IP^-1: 最後の逆初期置換
# -----------------------------------------------------------------------------
def IPinv_read(R15L15):
    base64bit = 1 << 64
    ciphertext = 0
    for i in range(len(IPinv)):
        pos = base64bit >> IPinv[i]
        ciphertext = ciphertext | ((R15L15 & pos) << (IPinv[i]-1) >> i)
    return ciphertext


# -----------------------------------------------------------------------------
# encryption: DES 本体（暗号化も復号も同じ関数で実現）
# -----------------------------------------------------------------------------
def encryption(plaintext, subkeys):
    # 1) 初期置換
    int_txt = IPread(plaintext)

    # 2) 16ラウンドの Feistel 構造
    for i in range(fullround):
        MASK32bit = 0xFFFFFFFF

        # 64bit を L(上位32) と R(下位32) に分割
        L = int_txt >> 32
        R = int_txt & MASK32bit

        # ---- F関数（R とサブ鍵）----
        # (a) E で 32->48 に展開
        ER = Eread(R)

        # (b) サブ鍵と XOR
        ERK = ER ^ subkeys[i]

        # (c) 48bit を 6bit×8 に分割し、それぞれ S-box を通す（48->32）
        Sout = 0
        for k in range(8):
            # k=0 が最上位 6bit、k=7 が最下位 6bit を取る
            Sb = (ERK >> ((7-k)*6)) & 0b111111  # 6bit 抽出
            Sout = Sout << 4                    # 次の 4bit を詰める準備
            Sboxval = Sboxread(k, Sb)           # 6bit -> 4bit
            Sout = Sout | Sboxval               # 4bit を連結

        # (d) P で並べ替え（拡散）
        PF = Pread(Sout)

        # ---- Feistel の更新 ----
        # Li+1 = Ri
        # Ri+1 = Li XOR F(Ri,Ki)
        #
        # この実装は「次の int_txt」を (R || (L XOR PF)) として再構成する。
        int_txt = (R << 32) | (L ^ PF)

    # 3) 最終 swap（R16 || L16）
    # ループ後の int_txt は (L16||R16) ではなく、
    # 上の更新式の形から (L16||R16) 相当が入っているが、DES 仕様では最後に swap を入れる。
    L15 = int_txt >> 32
    R15 = (int_txt & MASK32bit) << 32
    R15L15 = R15 | L15  # swap して (R16||L16) を作る

    # 4) 逆初期置換
    ciphertext = IPinv_read(R15L15)
    return ciphertext


# -----------------------------------------------------------------------------
# 動作確認（テストベクタ）
# -----------------------------------------------------------------------------
# ptext/key/ctext の組は、DES 実装が正しいか確認するための既知値（テストベクタ）として使える。
# （同じ入力なら同じ暗号文が出るのがブロック暗号の性質）
ptext = 0x123456ABCD132536
key   = 0xaabb09182736ccdd
ctext = 0xc0b7a8d05f3a829c

# 暗号化: subkeys を順方向で使う
subkeys = keyschedule(key)
ciphertext = encryption(ptext, subkeys)
print(hex(ciphertext))

# 復号: Feistel 構造の性質により、サブ鍵を逆順にして同じ encryption を回せば復号できる。
decsubkeys = keyschedule(key)[::-1]
plaintext = encryption(ctext, decsubkeys)
print(hex(plaintext))

# -----------------------------------------------------------------------------
# 追加メモ（学習ポイント）
# -----------------------------------------------------------------------------
# - DES は Feistel 暗号なので「暗号化と復号がほぼ同じ構造」で書ける。
#   違いはサブ鍵の適用順序だけ（暗号化: K1..K16、復号: K16..K1）。
# - 置換（IP/E/P/PC1/PC2）は「ビットの並べ替え」なので、本質的には線形操作である。
# - 強度の要は S-box による非線形性と、ラウンドを重ねることによる拡散である。
# - 実装上は「仕様テーブルが 1-indexed」である点がバグの温床になりやすい。
#   このコードでは base64bit/base32bit を用いて 1-indexed ビット位置を作り、
#   シフトで出力ビット位置へ詰め直すというスタイルで統一している。
