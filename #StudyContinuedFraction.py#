# 連分数（continued fraction）の係数列を求める関数
# -----------------------------------------------------------------------------
# 目的
# - 有理数 a/b を「単純連分数（simple continued fraction）」として表したときの
#   係数列 [c0, c1, c2, ..., ck] を求める。
#
# 単純連分数とは
# - 有理数（や無理数）を次の形で表す：
#
#     a/b = c0 + 1/(c1 + 1/(c2 + 1/( ... + 1/ck)...))
#
# ここで c0 は整数、c1..ck は正の整数になる（a,b が正なら）。
#
# 連分数とユークリッド互除法の関係（重要）
# - 有理数 a/b の連分数係数は、ユークリッドの互除法で出てくる「商」の列と一致する。
#
# つまり、
#   a = b*q0 + r0
#   b = r0*q1 + r1
#   r0 = r1*q2 + r2
#   ...
#   rk-1 = rk*qk + 0
# の q0, q1, q2, ..., qk が連分数の係数 [c0,c1,...,ck] になる。
vv#
# この関数はまさにその “商列を集める” 実装である。
#
# なぜ暗号理論で出てくるか
# - RSA の Wiener 攻撃などでは、e/N の連分数展開から秘密指数 d を推定する手法がある。
# - 連分数の収束分数（convergent）が最良近似の性質を持つため、鍵の弱点探索に使われる。
#
# 注意点（入力の前提）
# - b=0 だと a%b が例外になるので、b!=0 が必要。
# - a,b が負の場合、係数の符号や定義がブレるので、通常は正の有理数を想定する。
# - Python の // と % は負数で数学のユークリッド除算とずれることがあるため、
#   暗号/数論用途では正数入力を前提にするのが安全。


def cfrac(a, b):
    # a/b の連分数係数列を返す
    #
    # 例:
    #   a/b = 415/93
    #   415 = 93*4 + 43
    #    93 = 43*2 + 7
    #    43 = 7*6 + 1
    #     7 = 1*7 + 0
    #   係数列は [4,2,6,7]
    #
    # 実装はユークリッド互除法：
    #   q = a//b（商）
    #   r = a%b （余り）
    # を繰り返し、商 q をリストに積んでいく。

    r = a % b   # residue（余り r0）
    q = a // b  # quotient（商 q0）

    # 連分数の先頭係数 c0 を入れておく（=最初の商）
    coeflst = [q]

    # 余りが 0 になるまで繰り返す
    # - 互除法では余りが必ず小さくなっていくので有限回で停止する。
    while r != 0:
        # (a, b) を (b, r) に更新して次のステップへ
        a = b
        b = r

        # 次の商と余りを計算
        r = a % b
        q = a // b

        # 連分数の次の係数として商を追加
        coeflst.append(q)

    # r==0 になった時点で互除法が終了し、係数列が完成している
    return coeflst
