# OpenCV + PyCryptodome で「画像を AES で暗号化した見た目」を比較するデモ（ECB vs CBC）
# -----------------------------------------------------------------------------
# 目的
# - 画像（BMP）を読み込み、画素（バイト列）をそのまま AES で暗号化し、
#   暗号文を再び画像として保存して「見た目がどう崩れるか」を観察する。
# - とくに ECB と CBC の違い（パターン漏えいの有無）が視覚的に分かることが多い。
#
# 背景（なぜ画像でやると分かりやすい？）
# - 画像は「同じ色の領域」など、同じバイト列パターンが繰り返されやすい。
# - ECB は「同じ平文ブロック → 同じ暗号文ブロック」になるため、
#   画像の構造（輪郭など）が暗号化後も“うっすら見える”ことがある。
# - CBC は前ブロックとの XOR 連鎖が入るため、同じ平文ブロックでも
#   前段が違えば暗号文が変わり、構造が見えにくくなる。
#
# 重要（このコードの注意点：実行上の落とし穴）
# - AES(ECB/CBC) の encrypt は「入力長が16バイトの倍数」である必要がある。
#   img.tobytes() の長さが 16 の倍数でないと ValueError になる。
#   （BMP のサイズ次第ではたまたま通るが、一般にはパディングが必要）
# - CBC モードは IV（初期化ベクトル）が必要。PyCryptodome では
#   IV を渡さない場合はランダム IV が内部生成され、cipher.iv で参照できる。
# - このコードは「暗号化して画像として保存」するだけなので復号はしていない。
#   実務的な暗号では “改ざん検知（AEAD）” も必要だが、ここは学習用デモ。
#
# 重要（セキュリティ上の注意）
# - 画像暗号化を本当に行うなら、ファイルヘッダ（BMPヘッダ）や
#   メタデータ、パディング、IV/nonce の保存などを設計する必要がある。
# - ここでは「画像のピクセル配列をそのまま暗号化する」という視覚実験として扱う。


import cv2
import numpy as np
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

# -----------------------------------------------------------------------------
# 1) OpenCVで画像を読み込み
# -----------------------------------------------------------------------------
# cv2.imread は画像を NumPy 配列として返す。
# 典型的には shape=(height, width, channels) の uint8 配列になる。
# 例: カラー画像なら channels=3（BGR）で読み込まれることが多い。
img = cv2.imread("sampleFig.bmp")

# 読み込み失敗チェック（ファイルパス違いなど）
# img が None のままだと以降で落ちるので、最低限の確認を入れるのが実務的。
# （学習用なら print して止めるだけでも良い）
if img is None:
    raise FileNotFoundError("sampleFig.bmp が見つからないか、読み込めません。")

# 画像のサイズ情報（後で暗号文を同じ shape に戻すために使う）
h, w, d = img.shape

# -----------------------------------------------------------------------------
# 2) 画像（画素配列）を “生のバイト列” に変換
# -----------------------------------------------------------------------------
# img は uint8 の配列なので、tobytes() により
#   [B,G,R, B,G,R, ...] のような連続したバイト列に変換できる。
#
# 注意:
# - ここで「BMP のファイル形式」を暗号化しているわけではなく、
#   OpenCV がメモリ上に展開した “画素データそのもの” を暗号化している。
img_bytes = img.tobytes()

# AES のブロックサイズは 16 bytes（128bit）
bs = AES.block_size  # 16

# 入力長が 16 の倍数か確認
# - ECB/CBC の encrypt は長さが16の倍数でないと例外になる。
# - もし倍数でなければ PKCS#7 などでパディングしてから暗号化し、
#   復号時に unpad して元に戻す必要がある。
#
# このデモは「暗号文をそのまま画像に整形して保存する」ので、
# パディングを入れると暗号文サイズが増えて reshape が崩れる。
# そのため、デモとしては “入力長が16の倍数の画像” を選ぶか、
# 端数分を切り捨てて暗号化するなどの工夫が必要になる。
if len(img_bytes) % bs != 0:
    raise ValueError(
        f"画像バイト長が16の倍数ではありません: len={len(img_bytes)} "
        f"(len % 16 = {len(img_bytes) % bs}). "
        "ECB/CBC の encrypt は16の倍数が必要です。"
    )

# -----------------------------------------------------------------------------
# 3) AES-ECB で暗号化
# -----------------------------------------------------------------------------
# ECB は IV を使わず、各ブロックを独立に暗号化する。
# - 画像のような構造化データだと、パターンが残って見えることがある。
#
# 鍵は 16 bytes（AES-128）をランダム生成している。
# ※このコードでは鍵を保存していないので、復号はできない（デモ用途）。
key_ecb = get_random_bytes(16)
cipherECB = AES.new(key_ecb, AES.MODE_ECB)

# 暗号化
ciphertextECB = cipherECB.encrypt(img_bytes)

# -----------------------------------------------------------------------------
# 4) AES-CBC で暗号化
# -----------------------------------------------------------------------------
# CBC は IV が必要。
# - IV を渡さない場合、PyCryptodome がランダムに生成する。
# - 生成された IV は cipherCBC.iv で取得できる。
#
# 画像暗号化の「見た目比較」では、CBC は ECB より構造が消えやすいことが多い。
key_cbc = get_random_bytes(16)
cipherCBC = AES.new(key_cbc, AES.MODE_CBC)  # IV 未指定 → ランダム IV が内部生成

ciphertextCBC = cipherCBC.encrypt(img_bytes)
iv_cbc = cipherCBC.iv  # 参考：復号するなら保存が必要

# -----------------------------------------------------------------------------
# 5) 暗号文（バイト列）を “画像として見える形” に戻す
# -----------------------------------------------------------------------------
# ciphertext は bytes（長さは元の img_bytes と同じ）なので、
# np.frombuffer で uint8 の 1次元配列に変換し、元の (h,w,d) に reshape する。
#
# ここで暗号文をそのまま画素値として解釈しているため、
# 出力画像は「ノイズっぽい」見た目になる。
np_arrECB = np.frombuffer(ciphertextECB, np.uint8).reshape(h, w, d)
np_arrCBC = np.frombuffer(ciphertextCBC, np.uint8).reshape(h, w, d)

# -----------------------------------------------------------------------------
# 6) 画像として保存
# -----------------------------------------------------------------------------
# 出力ファイルは BMP として保存している。
# - BMP は圧縮がないことが多く、画素値の変化がそのまま見えるのでデモに向く。
cv2.imwrite("ECB_encrypted.bmp", np_arrECB)
cv2.imwrite("CBC_encrypted.bmp", np_arrCBC)

# -----------------------------------------------------------------------------
# 追加メモ（学習の次の一手）
# -----------------------------------------------------------------------------
# - ECB/CBC/CTR/GCM で同じことをやると「モードの性質」が可視化できて面白い。
# - CBC は IV を固定すると情報漏えいの原因になるので、実験として試す価値がある。
# - 実務的に画像を暗号化するなら、ヘッダを残す/暗号化する範囲、IV/nonce の保存、
#   認証（GCM 等）まで含めて設計する必要がある。
