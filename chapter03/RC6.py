# ブロック暗号 RC6（学習用：RC6-32/20/16 相当の実装）
# -----------------------------------------------------------------------------
# RC6 の基本仕様（一般表記：RC6-w/r/b）
# - w : ワード長（bits）            -> ここでは W=32
# - r : ラウンド数                  -> ここでは R=20
# - b : 鍵長（bytes）               -> ここでは B=128bits = 16bytes
#
# したがって本コードは概ね「RC6-32/20/16」に対応する。
#
# ブロック長
# - RC6 は 4ワードを扱うので、ブロック長は 4*w bits。
# - ここでは 4*32 = 128bit ブロック暗号。
#
# RC6 の構造（全体像）
# - 128bit ブロックを 32bit×4（A,B,C,D）に分割して処理する。
# - 各ラウンドで B と D から「データ依存回転量」を作り、
#   それを使って A と C を更新する（これが RC6 の特徴）。
# - 最後にワードを循環入れ替え（A,B,C,D = B,C,D,A）して拡散を強める。
#
# 鍵スケジュール
# - RC5/RC6 系の特徴として、鍵スケジュールで
#   L（鍵のワード列）と S（拡大鍵配列）を混ぜ合わせる。
# - S の長さは 2r+4（ラウンドごとに2個 + 前後の加算分）である。
#
# 注意（実務）
# - RC6 は AES 選定過程の最終候補の1つで、設計としては良く研究されているが、
#   実務では AES を使うのが一般的である。
# - 学習用として「データ依存回転」「ワード単位ARX（add-rotate-xor）＋乗算」が学べる。
#
# -----------------------------------------------------------------------------
# パラメータ（RC6-32/20/16）
# -----------------------------------------------------------------------------
W   = 32          # Word size in bits（ワード長）
Pw  = 0xb7e15163  # Magic constant Pw（e の小数部由来：鍵スケジュール初期値）
Qw  = 0x9e3779b9  # Magic constant Qw（黄金比由来：鍵スケジュール増分）
R   = 20          # Number of rounds（ラウンド数）
B   = 128         # Number of bits in key（鍵長：bits）
C   = 4           # Number of words in key（鍵をW-bitワードにした個数 = B/W = 4）
LGW = 5           # log2(W)（W=32なら5）


# -----------------------------------------------------------------------------
# 基本ユーティリティ：ローテートと mod 2^W の演算
# -----------------------------------------------------------------------------
# RC6 は「mod 2^W」上の加算（add）と減算（sub）、
# そしてローテート（rol/ror）と XOR を中心に構成される。
#
# 重要ポイント
# - Python の int は任意精度なので、RC6 の 32bit 演算を再現するには
#   常に mod 2^W（= &((1<<W)-1) と同等）で丸める必要がある。
# - この実装は % (1<<W) を使ってそれを実現している。

def rol(x, m):
    # 左回転（rotate left）
    # x を W-bit とみなし、m bit 左に循環シフトする。
    # 例: rol(0b1001,1) -> 0b0011 （W=4のとき）
    return (((x << m) | (x >> (W - m))) % (1 << W))

def ror(x, m):
    # 右回転（rotate right）
    return (((x >> m) | (x << (W - m))) % (1 << W))


# -----------------------------------------------------------------------------
# RC6 の f 関数（"データ依存回転" を作るための値生成）
# -----------------------------------------------------------------------------
# RC6 の特徴は、回転量がデータ（B や D）に依存する点。
# その回転量を作る前段として
#
#   f(x) = x * (2x + 1)  mod 2^W
#
# を使う（2x+1 は奇数なので、乗算がビット混合に効く）。
# さらにその出力を rol(..., LGW) して回転量生成に使う。
#
# なぜ LGW 回転？
# - W=32 の場合、LGW=5 で、回転量として使う下位5bit（0..31）を
#   より拡散させる狙いがある。

def f(x):
    # f(x) = x*(2x+1) mod 2^W
    return ((x * ((x << 1) + 1)) % (1 << W))


# -----------------------------------------------------------------------------
# mod 2^W の加算・減算（ARX系暗号の基本）
# -----------------------------------------------------------------------------
def sub(x, y):
    # (x - y) mod 2^W
    # Python で負になるのを避けるため、(2^W - y) を足して mod を取っている。
    return ((x + ((1 << W) - y)) % (1 << W))

def add(x, y):
    # (x + y) mod 2^W
    return ((x + y) % (1 << W))


# -----------------------------------------------------------------------------
# 鍵スケジュール：ユーザ鍵（key）から拡大鍵 S[0..2R+3] を生成
# -----------------------------------------------------------------------------
def keysched(key):
    # 1) ユーザ鍵 key（B bits）を W-bit ワード列 L[0..C-1] に分割
    #    - ここでは key を 128bit 整数として与え、上位から 32bit ずつ切り出す。
    l = [0 for _ in range(C)]

    # 2) 拡大鍵配列 S を生成（長さ 2R+4）
    #    - S[0] = Pw
    #    - S[i] = S[i-1] + Qw (mod 2^W)
    s = [0 for _ in range(2 * R + 4)]

    # key を 32bit ワードに分割して l に入れる
    # i=0 -> 最上位ワード
    # i=3 -> 最下位ワード
    for i in range(C):
        l[i] = (key >> (W * (C - 1 - i))) % (1 << W)

    # S 配列の初期化（算術級数的に作る）
    s[0] = Pw
    for i in range(1, 2 * R + 4):
        s[i] = add(s[i - 1], Qw)

    # 3) L と S を混ぜ合わせる "mixing" ステップ
    # RC5/RC6 の鍵スケジュールの肝：
    # - a, b を内部状態として持ち、
    # - S と L を交互に更新しながらローテートをかけて混ぜる。
    #
    # v = 3 * max(len(S), len(L)) 回繰り返すのが仕様。
    a = b = i = j = 0
    v = 3 * max([2 * R + 4, C])

    for _k in range(1, v + 1):
        # S[i] を更新：
        #   S[i] = rol(S[i] + a + b, 3)
        #   a = S[i]
        a = s[i] = rol(add(add(s[i], a), b), 3)

        # L[j] を更新：
        #   L[j] = rol(L[j] + a + b, (a+b) mod W)
        #   b = L[j]
        #
        # ここが「データ依存回転」の第一例で、
        # 回転量が (a+b) に依存して変化する。
        b = l[j] = rol(add(add(l[j], a), b), (add(a, b) % W))

        # i, j を循環させて次へ
        i = (i + 1) % (2 * R + 4)
        j = (j + 1) % C

    return s


# -----------------------------------------------------------------------------
# 暗号化/復号本体
# -----------------------------------------------------------------------------
def ciph(x, s, ed):
    # x : 128bit ブロック（整数）
    # s : 拡大鍵配列 S（長さ 2R+4）
    # ed: 0=暗号化, 1=復号
    #
    # 128bit を 32bit×4（A,B,C,D）に分割
    # ここでは x を上位から
    #   A = bits[127:96], B = bits[95:64], C = bits[63:32], D = bits[31:0]
    # として扱う。
    a = (x >> (3 * W))
    b = ((x >> (2 * W)) % (1 << W))
    c = ((x >> W) % (1 << W))
    d = (x % (1 << W))

    # -----------------------------
    # 暗号化（ed=0）
    # -----------------------------
    if ed == 0:
        # 初期鍵加算（pre-whitening）
        # B と D に S[0], S[1] を足す
        b = add(b, s[0])
        d = add(d, s[1])

        # ラウンド i=1..R
        for i in range(1, R + 1):
            # t = rol(f(B), LGW)
            # u = rol(f(D), LGW)
            #
            # t,u は「回転量として使う値」を作るための中間値。
            # 後で (u % W), (t % W) を回転量として利用する。
            t = rol(f(b), LGW)
            u = rol(f(d), LGW)

            # A と C を更新（RC6 のコア）
            # A = ( (A XOR t) <<< (u mod W) ) + S[2i]
            # C = ( (C XOR u) <<< (t mod W) ) + S[2i+1]
            #
            # ここで "<<<" は左回転。
            a = add(rol((a ^ t), (u % W)), s[2 * i])
            c = add(rol((c ^ u), (t % W)), s[2 * i + 1])

            # ワードの巡回入れ替え（拡散のため）
            # (A,B,C,D) = (B,C,D,A)
            a, b, c, d = b, c, d, a

        # 最終鍵加算（post-whitening）
        a = add(a, s[2 * R + 2])
        c = add(c, s[2 * R + 3])

    # -----------------------------
    # 復号（ed=1）
    # -----------------------------
    else:
        # 暗号化の post-whitening を逆に戻す
        c = sub(c, s[2 * R + 3])
        a = sub(a, s[2 * R + 2])

        # ラウンドを逆順に回す（i=R..1）
        for i in range(R, 0, -1):
            # 暗号化で行った巡回入れ替えの逆
            # 暗号化: (A,B,C,D) = (B,C,D,A)
            # 逆は   : (A,B,C,D) = (D,A,B,C)
            a, b, c, d = d, a, b, c

            # t,u は暗号化時と同じ式で作れる（Feistelではないが可逆性を確保している）
            u = rol(f(d), LGW)
            t = rol(f(b), LGW)

            # 暗号化の更新式を逆変換する
            # 暗号化:
            #   C = rol(C XOR u, tmod) + S[2i+1]
            # 復号:
            #   C = ror(C - S[2i+1], tmod) XOR u
            #
            # 同様に A も戻す。
            c = ror(sub(c, s[2 * i + 1]), (t % W)) ^ u
            a = ror(sub(a, s[2 * i]), (u % W)) ^ t

        # 暗号化の pre-whitening を逆に戻す
        d = sub(d, s[1])
        b = sub(b, s[0])

    # 32bit×4 を 128bit に再結合して返す
    return (a << (3 * W)) | (b << (2 * W)) | (c << W) | d


# -----------------------------------------------------------------------------
# 動作確認（テスト）
# -----------------------------------------------------------------------------
txt = 0x3524130279685746bdac9b8af1e0dfce  # Plaintext（平文, 128bit）
key = 0x67452301efcdab893423120178675645  # Secret Key（秘密鍵, 128bit）

s   = keysched(key)      # Key Schedule（拡大鍵 S を生成）
ctx = ciph(txt, s, 0)    # 暗号化

print(format(ctx, '032x'))           # 暗号文の表示（128bit=32桁16進）
print(format(ciph(ctx, s, 1), '032x'))  # 復号（元の平文に戻るはず）
